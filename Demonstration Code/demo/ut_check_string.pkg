CREATE OR REPLACE PACKAGE ut_check_string
-- Generated by gen_ut_check_string.sql. Do not modify this file!
IS
   PROCEDURE ut_setup;
   PROCEDURE ut_teardown;
 
   -- For each program to test...
   PROCEDURE ut_IS_ALPHA_NUMERIC;
   PROCEDURE ut_IS_DIGIT;
   PROCEDURE ut_IS_IDENTIFIER;
   PROCEDURE ut_IS_NUMBER;
   PROCEDURE ut_ONLY_LETTERS;
END ut_check_string;
/

CREATE OR REPLACE PACKAGE BODY UT_check_string
IS
   PROCEDURE UT_setup
   IS
   BEGIN
      NULL;
   END;
   
   PROCEDURE UT_teardown
   IS
   BEGIN
      NULL;
   END;
   -- For each program to test...
   PROCEDURE UT_IS_ALPHA_NUMERIC
   IS
      -- Verify and complete data types.
      against_this BOOLEAN;
      check_this BOOLEAN;
   BEGIN
      
      -- Define "control" operation for "AN-valid string"
       
      against_this := TRUE;
       
      -- Execute test code for "AN-valid string"
       
      check_this := 
      CHECK_STRING.IS_ALPHA_NUMERIC (
         STR_IN => 'abc44rr6'
         ,
         NUMERIC_FORMAT_IN => NULL
       );
       
      -- Assert success for "AN-valid string"
       
      -- Compare the two values.
      utAssert.eq (
         'bunch of letters and numbers',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "AN-valid string"
      
      -- Define "control" operation for "AN-delimiters all"
       
      against_this := FALSE;
       
      -- Execute test code for "AN-delimiters all"
       
      check_this := 
      CHECK_STRING.IS_ALPHA_NUMERIC (
         STR_IN => '_$#%^@'
         ,
         NUMERIC_FORMAT_IN => NULL
       );
       
      -- Assert success for "AN-delimiters all"
       
      -- Compare the two values.
      utAssert.eq (
         'a string with only delimiters',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "AN-delimiters all"
      
      -- Define "control" operation for "AN-letters and delimiters"
       
      against_this := FALSE;
       
      -- Execute test code for "AN-letters and delimiters"
       
      check_this := 
      CHECK_STRING.IS_ALPHA_NUMERIC (
         STR_IN => 'abc$def'
         ,
         NUMERIC_FORMAT_IN => NULL
       );
       
      -- Assert success for "AN-letters and delimiters"
       
      -- Compare the two values.
      utAssert.eq (
         'a string with letters and delimiters',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "AN-letters and delimiters"
      
      -- Define "control" operation for "AN-pass null"
       
      against_this := FALSE;
       
      -- Execute test code for "AN-pass null"
       
      check_this := 
      CHECK_STRING.IS_ALPHA_NUMERIC (
         STR_IN => NULL
         ,
         NUMERIC_FORMAT_IN => NULL
       );
       
      -- Assert success for "AN-pass null"
       
      -- Check for NULL return value.
      utAssert.isNULL (
         'a null string is passed',
         check_this
         );
      
      -- End of test for "AN-pass null"
   END UT_IS_ALPHA_NUMERIC;

   PROCEDURE UT_IS_DIGIT
   IS
      -- Verify and complete data types.
      against_this BOOLEAN;
      check_this BOOLEAN;
   BEGIN
      
      -- Define "control" operation for "single letter for digit"
       
      against_this := FALSE;
       
      -- Execute test code for "single letter for digit"
       
      check_this := 
      CHECK_STRING.IS_DIGIT (
         CHARACTER_IN => 'a'
       );
       
      -- Assert success for "single letter for digit"
       
      -- Compare the two values.
      utAssert.eq (
         'the string contains a single letter',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "single letter for digit"
      
      -- Define "control" operation for "single number for digit"
       
      against_this := TRUE;
       
      -- Execute test code for "single number for digit"
       
      check_this := 
      CHECK_STRING.IS_DIGIT (
         CHARACTER_IN => '3'
       );
       
      -- Assert success for "single number for digit"
       
      -- Compare the two values.
      utAssert.eq (
         'the string contains a single number',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "single number for digit"
      
      -- Define "control" operation for "single delimiter for digit"
       
      against_this := FALSE;
       
      -- Execute test code for "single delimiter for digit"
       
      check_this := 
      CHECK_STRING.IS_DIGIT (
         CHARACTER_IN => '\'
       );
       
      -- Assert success for "single delimiter for digit"
       
      -- Compare the two values.
      utAssert.eq (
         'the string contains a single delimiter',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "single delimiter for digit"
      
      -- Define "control" operation for "ID-pass null"
       
      against_this := FALSE;
       
      -- Execute test code for "ID-pass null"
       
      check_this := 
      CHECK_STRING.IS_DIGIT (
         CHARACTER_IN => NULL
       );
       
      -- Assert success for "ID-pass null"
       
      -- Check for NULL return value.
      utAssert.isNULL (
         'a null string is passed',
         check_this
         );
      
      -- End of test for "ID-pass null"
   END UT_IS_DIGIT;

   PROCEDURE UT_IS_IDENTIFIER
   IS
      -- Verify and complete data types.
      against_this BOOLEAN;
      check_this BOOLEAN;
   BEGIN
      
      -- Define "control" operation for "IDENT-all letters"
       
      against_this := TRUE;
       
      -- Execute test code for "IDENT-all letters"
       
      check_this := 
      CHECK_STRING.IS_IDENTIFIER (
         STR_IN => 'is_letter'
       );
       
      -- Assert success for "IDENT-all letters"
       
      -- Compare the two values.
      utAssert.eq (
         'standard valid identifer, all letters',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "IDENT-all letters"
      
      -- Define "control" operation for "IDENT-regular name"
       
      against_this := TRUE;
       
      -- Execute test code for "IDENT-regular name"
       
      check_this := 
      CHECK_STRING.IS_IDENTIFIER (
         STR_IN => 'check_string'
       );
       
      -- Assert success for "IDENT-regular name"
       
      -- Compare the two values.
      utAssert.eq (
         'Normal, valid name of program',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "IDENT-regular name"
      
      -- Define "control" operation for "IDENT-bad delimiters"
       
      against_this := FALSE;
       
      -- Execute test code for "IDENT-bad delimiters"
       
      check_this := 
      CHECK_STRING.IS_IDENTIFIER (
         STR_IN => 'check-string'
       );
       
      -- Assert success for "IDENT-bad delimiters"
       
      -- Compare the two values.
      utAssert.eq (
         'Program name with hyphen',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "IDENT-bad delimiters"
      
      -- Define "control" operation for "IDENT-anything goes"
       
      against_this := TRUE;
       
      -- Execute test code for "IDENT-anything goes"
       
      check_this := 
      CHECK_STRING.IS_IDENTIFIER (
         STR_IN => '"^this is@crazy"'
       );
       
      -- Assert success for "IDENT-anything goes"
       
      -- Compare the two values.
      utAssert.eq (
         'Crazy string inside double quotes',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "IDENT-anything goes"
      
      -- Define "control" operation for "IDENT-too long"
       
      against_this := FALSE;
       
      -- Execute test code for "IDENT-too long"
       
      check_this := 
      CHECK_STRING.IS_IDENTIFIER (
         STR_IN => 'a123456789b123456789c123456789d123456789'
       );
       
      -- Assert success for "IDENT-too long"
       
      -- Compare the two values.
      utAssert.eq (
         'Identifier with more than 30 characters',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "IDENT-too long"
   END UT_IS_IDENTIFIER;

   PROCEDURE UT_IS_LETTER
   IS
      -- Verify and complete data types.
      against_this BOOLEAN;
      check_this BOOLEAN;
   BEGIN
      
      -- Define "control" operation for "single letter for letter"
       
      against_this := TRUE;
       
      -- Execute test code for "single letter for letter"
       
      check_this := 
      CHECK_STRING.IS_LETTER (
         CHARACTER_IN => 'a'
       );
       
      -- Assert success for "single letter for letter"
       
      -- Compare the two values.
      utAssert.eq (
         'the string contains a single letter',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "single letter for letter"
      
      -- Define "control" operation for "single number for letter"
       
      against_this := FALSE;
       
      -- Execute test code for "single number for letter"
       
      check_this := 
      CHECK_STRING.IS_LETTER (
         CHARACTER_IN => '3'
       );
       
      -- Assert success for "single number for letter"
       
      -- Compare the two values.
      utAssert.eq (
         'the string contains a single number',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "single number for letter"
      
      -- Define "control" operation for "single delimiter for letter"
       
      against_this := FALSE;
       
      -- Execute test code for "single delimiter for letter"
       
      check_this := 
      CHECK_STRING.IS_LETTER (
         CHARACTER_IN => '\'
       );
       
      -- Assert success for "single delimiter for letter"
       
      -- Compare the two values.
      utAssert.eq (
         'the string contains a single delimiter',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "single delimiter for letter"
      
      -- Define "control" operation for "IL-pass null"
       
      against_this := FALSE;
       
      -- Execute test code for "IL-pass null"
       
      check_this := 
      CHECK_STRING.IS_LETTER (
         CHARACTER_IN => NULL
       );
       
      -- Assert success for "IL-pass null"
       
      -- Check for NULL return value.
      utAssert.isNULL (
         'a null string is passed',
         check_this
         );
      
      -- End of test for "IL-pass null"
   END UT_IS_LETTER;

   PROCEDURE UT_IS_NUMBER
   IS
      -- Verify and complete data types.
      against_this BOOLEAN;
      check_this BOOLEAN;
   BEGIN
      
      -- Define "control" operation for "only digits"
       
      against_this := TRUE;
       
      -- Execute test code for "only digits"
       
      check_this := 
      CHECK_STRING.IS_NUMBER (
         STR_IN => '123456'
         ,
         NUMERIC_FORMAT_IN => NULL
       );
       
      -- Assert success for "only digits"
       
      -- Compare the two values.
      utAssert.eq (
         'the string contains only digits 0-9',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "only digits"
      
      -- Define "control" operation for "digits with decimal delimiter"
       
      against_this := TRUE;
       
      -- Execute test code for "digits with decimal delimiter"
       
      check_this := 
      CHECK_STRING.IS_NUMBER (
         STR_IN => '12345600.567'
         ,
         NUMERIC_FORMAT_IN => NULL
       );
       
      -- Assert success for "digits with decimal delimiter"
       
      -- Compare the two values.
      utAssert.eq (
         'contains digits 0-9 plus decimal delimiter',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "digits with decimal delimiter"
      
      -- Define "control" operation for "scientific notation"
       
      against_this := TRUE;
       
      -- Execute test code for "scientific notation"
       
      check_this := 
      CHECK_STRING.IS_NUMBER (
         STR_IN => '12e55'
         ,
         NUMERIC_FORMAT_IN => NULL
       );
       
      -- Assert success for "scientific notation"
       
      -- Compare the two values.
      utAssert.eq (
         'uses "e" syntax',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "scientific notation"
      
      -- Define "control" operation for "IN-pass null"
       
      against_this := FALSE;
       
      -- Execute test code for "IN-pass null"
       
      check_this := 
      CHECK_STRING.IS_NUMBER (
         STR_IN => NULL
         ,
         NUMERIC_FORMAT_IN => NULL
       );
       
      -- Assert success for "IN-pass null"
       
      -- Check for NULL return value.
      utAssert.isNULL (
         'a null string is passed',
         check_this
         );
      
      -- End of test for "IN-pass null"
   END UT_IS_NUMBER;

   PROCEDURE UT_ONLY_LETTERS
   IS
      -- Verify and complete data types.
      against_this BOOLEAN;
      check_this BOOLEAN;
   BEGIN
      
      -- Define "control" operation for "OL-surname"
       
      against_this := TRUE;
       
      -- Execute test code for "OL-surname"
       
      check_this := 
      CHECK_STRING.ONLY_LETTERS (
         STR_IN => 'Feuerstein'
       );
       
      -- Assert success for "OL-surname"
       
      -- Compare the two values.
      utAssert.eq (
         'a string with just my last name',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "OL-surname"
      
      -- Define "control" operation for "OL-partname"
       
      against_this := FALSE;
       
      -- Execute test code for "OL-partname"
       
      check_this := 
      CHECK_STRING.ONLY_LETTERS (
         STR_IN => 'WIDGET107'
       );
       
      -- Assert success for "OL-partname"
       
      -- Compare the two values.
      utAssert.eq (
         'a string with letters and numbers - a part name',
         check_this,
         against_this
         ,null_ok_in => TRUE
         );
      
      -- End of test for "OL-partname"
      
      -- Define "control" operation for "OL-pass null"
       
      against_this := FALSE;
       
      -- Execute test code for "OL-pass null"
       
      check_this := 
      CHECK_STRING.ONLY_LETTERS (
         STR_IN => NULL
       );
       
      -- Assert success for "OL-pass null"
       
      -- Check for NULL return value.
      utAssert.isNULL (
         'a null string is passed',
         check_this
         );
      
      -- End of test for "OL-pass null"
   END UT_ONLY_LETTERS;

END UT_check_string;
/
