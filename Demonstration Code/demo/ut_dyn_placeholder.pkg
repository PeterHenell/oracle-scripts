CREATE OR REPLACE PACKAGE UT_DYN_PLACEHOLDER
/*
| Unit Test Package for DYN_PLACEHOLDER
|
| Generated by Qute -- the Quick Unit Test Engine (www.unit-test.com)
| Generated on 2006-01-26 08:07:10
|
| This package may be run from within any PL/SQL execution environment.
| by executing the following statements:
|
|    SET SERVEROUTPUT ON FORMAT WRAPPED SIZE 1000000
|
|    BEGIN
|       DYN_PLACEHOLDER.run_all_tests;
|    END;
|    /
|
| Results will be displayed via DBMS_OUTPUT. This package requires the
| presence of the qu_assert package. If you do not have Qute installed,
| you can download just the qu_assert package from:
|
|      http://www.unit-test.com/download/qu_assert.zip
|
| Then use the following statements to install all needed objects
| (assuming the program you want to test is already installed):
|
|    -- Assertion package
|    @qu_assert.pks
|    @qu_assert.pkb
|
|    -- Test code 
|    @UT_DYN_PLACEHOLDER.pkg
|
*/
IS
   PROCEDURE UT_setup;
   PROCEDURE UT_teardown;
    
   PROCEDURE UT_ALL_IN_STRING;
   PROCEDURE UT_COUNT_IN_STRING;
   PROCEDURE UT_NTH_IN_STRING;
   PROCEDURE run_all_tests;
END UT_DYN_PLACEHOLDER;

/


CREATE OR REPLACE PACKAGE BODY UT_DYN_PLACEHOLDER
/*
| Unit Test Package for DYN_PLACEHOLDER
|
| Generated by Qute -- the Quick Unit Test Engine (www.unit-test.com)
| Generated on 2006-01-26 08:07:10
|
| This package may be run from within any PL/SQL execution environment.
| by executing the following statements:
|
|    SET SERVEROUTPUT ON FORMAT WRAPPED SIZE 1000000
|
|    BEGIN
|       DYN_PLACEHOLDER.run_all_tests;
|    END;
|    /
|
| Results will be displayed via DBMS_OUTPUT. This package requires the
| presence of the qu_assert package. If you do not have Qute installed,
| you can download just the qu_assert package from:
|
|      http://www.unit-test.com/download/qu_assert.zip
|
| Then use the following statements to install all needed objects
| (assuming the program you want to test is already installed):
|
|    -- Assertion package
|    @qu_assert.pks
|    @qu_assert.pkb
|
|    -- Test code 
|    @UT_DYN_PLACEHOLDER.pkg
|
*/
IS
FUNCTION error_info RETURN VARCHAR2 IS
   l_return VARCHAR2(32767);
   l_stack VARCHAR2(32767);
BEGIN
   l_return := DBMS_UTILITY.FORMAT_ERROR_STACK;
   BEGIN
      EXECUTE IMMEDIATE 
        'BEGIN :val := ''PL/SQL Error Backtrace: '' 
             || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE; END;'
      USING OUT l_stack;
   EXCEPTION
      WHEN OTHERS THEN l_stack := DBMS_UTILITY.FORMAT_CALL_STACK;
   END;
   RETURN l_return || CHR(10) || l_stack;
END error_info;
 
   PROCEDURE UT_setup IS
   BEGIN
      NULL; -- Included to ensure that this procedure will compile if empty.
   END UT_setup;
    
   PROCEDURE UT_teardown IS
   BEGIN
      NULL; -- Included to ensure that this procedure will compile if empty.
   END UT_teardown;
    
   PROCEDURE UT_ALL_IN_STRING
   -- Unit test procedure for ALL_IN_STRING
   IS
      PROCEDURE Assignment_operator_in_string_
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
      "Expected Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
         PROCEDURE setup IS
         BEGIN
            -- Qute START CUSTOM SETUP for TESTCASE {AA7761C9-B8CA-4006-BFAE-3C6A49C181F5}
            -- Place all your custom setup code between these START and END comments.
            -- Don't forget to initialize this "expected value" collection!
-- "Expected Value From Function"(N) := VALUE;
-- In this case, I do not set any values in the expected collection,
-- because there are not placeholders.
            -- Qute END CUSTOM SETUP for TESTCASE {AA7761C9-B8CA-4006-BFAE-3C6A49C181F5}
             
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.ALL_IN_STRING(
                  STRING_IN => 'abc := def'
                  ,DYN_PLSQL_IN => NULL
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{AA7761C9-B8CA-4006-BFAE-3C6A49C181F5}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            /*
Before running your test, populate the "Expected Value From Function" collection 
in the test case Initialization section with the data you expect to
see in the "Value From Function" collection.
*/         
DECLARE
   c_match_index_values BOOLEAN := '' = 'Y';
   c_null_ok CONSTANT BOOLEAN := TRUE;
   c_stop_test CONSTANT BOOLEAN := FALSE;
   c_fp_count CONSTANT PLS_INTEGER := "Value From Function".COUNT;
   c_exp_count CONSTANT PLS_INTEGER := "Expected Value From Function".COUNT;
   --
   l_fp_index PLS_INTEGER := NVL (NULL, "Value From Function".FIRST); 
   l_exp_index PLS_INTEGER := NVL (NULL, "Expected Value From Function".FIRST);
   l_fp_last PLS_INTEGER := NVL (NULL, "Value From Function".LAST); 
   l_exp_last PLS_INTEGER := NVL (NULL, "Expected Value From Function".LAST);
   -- 
   l_message VARCHAR2 ( 32767 ) := 'The "from program" and "expected" collections contain the same contents.';
   different_collections EXCEPTION;
   FUNCTION elements_different (fp_index_in IN PLS_INTEGER, exp_index_in IN PLS_INTEGER) RETURN BOOLEAN
   IS BEGIN
      RETURN NOT ( DYN_PLACEHOLDER.EQ ( "Expected Value From Function"  ( exp_index_in )
                               , "Value From Function" ( fp_index_in )
                               , c_null_ok
                               )
                 );
   END elements_different;
BEGIN
   IF c_fp_count <> c_exp_count
   THEN
      l_message :=
            'From program count of ' || c_fp_count
         || ' does not match expected count of ' || c_exp_count;
      RAISE different_collections;
   END IF;
   LOOP
      EXIT WHEN (l_fp_index IS NULL AND l_exp_index IS NULL) 
            OR (l_fp_index > l_fp_last OR l_exp_index > l_exp_last);
      IF c_match_index_values AND l_fp_index <> l_exp_index
      THEN
         l_message := 'From program index ' || l_fp_index
            || ' does not match expected index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      IF elements_different ( l_fp_index, l_exp_index )
      THEN
         l_message := 'From program element at index ' || l_fp_index 
                 || ' does not match expected element at index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      l_fp_index := "Value From Function".NEXT ( l_fp_index );
      l_exp_index := "Expected Value From Function".NEXT ( l_exp_index );
   END LOOP;
   
   qu_assert.this ( '{3FF087C2-04FE-4876-A0DF-77FA40784050}', l_message , TRUE);
EXCEPTION
   WHEN different_collections
   THEN
      qu_assert.this ( '{3FF087C2-04FE-4876-A0DF-77FA40784050}', l_message , FALSE);
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
   WHEN OTHERS
   THEN
      qu_assert.report_result ( '{3FF087C2-04FE-4876-A0DF-77FA40784050}', l_message, error_info );
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "Assignment operator in string, no placeholders"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END Assignment_operator_in_string_;
       
      PROCEDURE Multiple_placeholders_in_strin
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
      "Expected Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
         PROCEDURE setup IS
         BEGIN
            -- Qute START CUSTOM SETUP for TESTCASE {4F6CFF20-8A02-45BF-B117-1C0FFA81C930}
            -- Place all your custom setup code between these START and END comments.
            -- Don't forget to initialize this "expected value" collection!
-- "Expected Value From Function"(N) := VALUE;
-- abc :def hij :krs :123
"Expected Value From Function"(1).name := 'DEF';
"Expected Value From Function"(1).position := '5';
"Expected Value From Function"(2).name := 'KRS';
"Expected Value From Function"(2).position := '14';
"Expected Value From Function"(3).name := '123';
"Expected Value From Function"(3).position := '19';
            -- Qute END CUSTOM SETUP for TESTCASE {4F6CFF20-8A02-45BF-B117-1C0FFA81C930}
             
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.ALL_IN_STRING(
                  STRING_IN => 'abc :def hij :krs :123'
                  ,DYN_PLSQL_IN => NULL
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{4F6CFF20-8A02-45BF-B117-1C0FFA81C930}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            /*
Before running your test, populate the "Expected Value From Function" collection 
in the test case Initialization section with the data you expect to
see in the "Value From Function" collection.
*/         
DECLARE
   c_match_index_values BOOLEAN := '' = 'Y';
   c_null_ok CONSTANT BOOLEAN := TRUE;
   c_stop_test CONSTANT BOOLEAN := FALSE;
   c_fp_count CONSTANT PLS_INTEGER := "Value From Function".COUNT;
   c_exp_count CONSTANT PLS_INTEGER := "Expected Value From Function".COUNT;
   --
   l_fp_index PLS_INTEGER := NVL (NULL, "Value From Function".FIRST); 
   l_exp_index PLS_INTEGER := NVL (NULL, "Expected Value From Function".FIRST);
   l_fp_last PLS_INTEGER := NVL (NULL, "Value From Function".LAST); 
   l_exp_last PLS_INTEGER := NVL (NULL, "Expected Value From Function".LAST);
   -- 
   l_message VARCHAR2 ( 32767 ) := 'The "from program" and "expected" collections contain the same contents.';
   different_collections EXCEPTION;
   FUNCTION elements_different (fp_index_in IN PLS_INTEGER, exp_index_in IN PLS_INTEGER) RETURN BOOLEAN
   IS BEGIN
      RETURN NOT ( DYN_PLACEHOLDER.EQ ( "Expected Value From Function"  ( exp_index_in )
                               , "Value From Function" ( fp_index_in )
                               , c_null_ok
                               )
                 );
   END elements_different;
BEGIN
   IF c_fp_count <> c_exp_count
   THEN
      l_message :=
            'From program count of ' || c_fp_count
         || ' does not match expected count of ' || c_exp_count;
      RAISE different_collections;
   END IF;
   LOOP
      EXIT WHEN (l_fp_index IS NULL AND l_exp_index IS NULL) 
            OR (l_fp_index > l_fp_last OR l_exp_index > l_exp_last);
      IF c_match_index_values AND l_fp_index <> l_exp_index
      THEN
         l_message := 'From program index ' || l_fp_index
            || ' does not match expected index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      IF elements_different ( l_fp_index, l_exp_index )
      THEN
         l_message := 'From program element at index ' || l_fp_index 
                 || ' does not match expected element at index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      l_fp_index := "Value From Function".NEXT ( l_fp_index );
      l_exp_index := "Expected Value From Function".NEXT ( l_exp_index );
   END LOOP;
   
   qu_assert.this ( '{DD6A7C94-8873-45EF-80A4-3086C47C7552}', l_message , TRUE);
EXCEPTION
   WHEN different_collections
   THEN
      qu_assert.this ( '{DD6A7C94-8873-45EF-80A4-3086C47C7552}', l_message , FALSE);
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
   WHEN OTHERS
   THEN
      qu_assert.report_result ( '{DD6A7C94-8873-45EF-80A4-3086C47C7552}', l_message, error_info );
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "Multiple placeholders in string"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END Multiple_placeholders_in_strin;
       
      PROCEDURE No_placeholders_in_string
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
      "Expected Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
         PROCEDURE setup IS
         BEGIN
            -- Qute START CUSTOM SETUP for TESTCASE {3200083C-D945-43C4-A5E1-B766AE3E159A}
            -- Place all your custom setup code between these START and END comments.
            -- Don't forget to initialize this "expected value" collection!
-- "Expected Value From Function"(N) := VALUE;
-- In this case, I do not set any values in the expected collection,
-- because there are not placeholders.
            -- Qute END CUSTOM SETUP for TESTCASE {3200083C-D945-43C4-A5E1-B766AE3E159A}
             
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.ALL_IN_STRING(
                  STRING_IN => 'abc def'
                  ,DYN_PLSQL_IN => NULL
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{3200083C-D945-43C4-A5E1-B766AE3E159A}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            /*
Before running your test, populate the "Expected Value From Function" collection 
in the test case Initialization section with the data you expect to
see in the "Value From Function" collection.
*/         
DECLARE
   c_match_index_values BOOLEAN := '' = 'Y';
   c_null_ok CONSTANT BOOLEAN := TRUE;
   c_stop_test CONSTANT BOOLEAN := FALSE;
   c_fp_count CONSTANT PLS_INTEGER := "Value From Function".COUNT;
   c_exp_count CONSTANT PLS_INTEGER := "Expected Value From Function".COUNT;
   --
   l_fp_index PLS_INTEGER := NVL (NULL, "Value From Function".FIRST); 
   l_exp_index PLS_INTEGER := NVL (NULL, "Expected Value From Function".FIRST);
   l_fp_last PLS_INTEGER := NVL (NULL, "Value From Function".LAST); 
   l_exp_last PLS_INTEGER := NVL (NULL, "Expected Value From Function".LAST);
   -- 
   l_message VARCHAR2 ( 32767 ) := 'The "from program" and "expected" collections contain the same contents.';
   different_collections EXCEPTION;
   FUNCTION elements_different (fp_index_in IN PLS_INTEGER, exp_index_in IN PLS_INTEGER) RETURN BOOLEAN
   IS BEGIN
      RETURN NOT ( DYN_PLACEHOLDER.EQ ( "Expected Value From Function"  ( exp_index_in )
                               , "Value From Function" ( fp_index_in )
                               , c_null_ok
                               )
                 );
   END elements_different;
BEGIN
   IF c_fp_count <> c_exp_count
   THEN
      l_message :=
            'From program count of ' || c_fp_count
         || ' does not match expected count of ' || c_exp_count;
      RAISE different_collections;
   END IF;
   LOOP
      EXIT WHEN (l_fp_index IS NULL AND l_exp_index IS NULL) 
            OR (l_fp_index > l_fp_last OR l_exp_index > l_exp_last);
      IF c_match_index_values AND l_fp_index <> l_exp_index
      THEN
         l_message := 'From program index ' || l_fp_index
            || ' does not match expected index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      IF elements_different ( l_fp_index, l_exp_index )
      THEN
         l_message := 'From program element at index ' || l_fp_index 
                 || ' does not match expected element at index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      l_fp_index := "Value From Function".NEXT ( l_fp_index );
      l_exp_index := "Expected Value From Function".NEXT ( l_exp_index );
   END LOOP;
   
   qu_assert.this ( '{90260220-1722-4B18-94B8-841C842CDB59}', l_message , TRUE);
EXCEPTION
   WHEN different_collections
   THEN
      qu_assert.this ( '{90260220-1722-4B18-94B8-841C842CDB59}', l_message , FALSE);
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
   WHEN OTHERS
   THEN
      qu_assert.report_result ( '{90260220-1722-4B18-94B8-841C842CDB59}', l_message, error_info );
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "No placeholders in string"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END No_placeholders_in_string;
       
      PROCEDURE One_placeholder_at_beginning_o
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
      "Expected Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
         PROCEDURE setup IS
         BEGIN
            -- Qute START CUSTOM SETUP for TESTCASE {9887667A-536B-4EF5-8C1D-786F0A834CDD}
            -- Place all your custom setup code between these START and END comments.
            -- Don't forget to initialize this "expected value" collection!
-- "Expected Value From Function"(N) := VALUE;
"Expected Value From Function"(1).name := 'ABC';
"Expected Value From Function"(1).position := '1';
            -- Qute END CUSTOM SETUP for TESTCASE {9887667A-536B-4EF5-8C1D-786F0A834CDD}
             
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.ALL_IN_STRING(
                  STRING_IN => ':abc def'
                  ,DYN_PLSQL_IN => NULL
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{9887667A-536B-4EF5-8C1D-786F0A834CDD}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            /*
Before running your test, populate the "Expected Value From Function" collection 
in the test case Initialization section with the data you expect to
see in the "Value From Function" collection.
*/         
DECLARE
   c_match_index_values BOOLEAN := 'TRUE' = 'Y';
   c_null_ok CONSTANT BOOLEAN := TRUE;
   c_stop_test CONSTANT BOOLEAN := FALSE;
   c_fp_count CONSTANT PLS_INTEGER := "Value From Function".COUNT;
   c_exp_count CONSTANT PLS_INTEGER := "Expected Value From Function".COUNT;
   --
   l_fp_index PLS_INTEGER := NVL (NULL, "Value From Function".FIRST); 
   l_exp_index PLS_INTEGER := NVL (NULL, "Expected Value From Function".FIRST);
   l_fp_last PLS_INTEGER := NVL (NULL, "Value From Function".LAST); 
   l_exp_last PLS_INTEGER := NVL (NULL, "Expected Value From Function".LAST);
   -- 
   l_message VARCHAR2 ( 32767 ) := 'The "from program" and "expected" collections contain the same contents.';
   different_collections EXCEPTION;
   FUNCTION elements_different (fp_index_in IN PLS_INTEGER, exp_index_in IN PLS_INTEGER) RETURN BOOLEAN
   IS BEGIN
      RETURN NOT ( DYN_PLACEHOLDER.EQ ( "Expected Value From Function"  ( exp_index_in )
                               , "Value From Function" ( fp_index_in )
                               , c_null_ok
                               )
                 );
   END elements_different;
BEGIN
   IF c_fp_count <> c_exp_count
   THEN
      l_message :=
            'From program count of ' || c_fp_count
         || ' does not match expected count of ' || c_exp_count;
      RAISE different_collections;
   END IF;
   LOOP
      EXIT WHEN (l_fp_index IS NULL AND l_exp_index IS NULL) 
            OR (l_fp_index > l_fp_last OR l_exp_index > l_exp_last);
      IF c_match_index_values AND l_fp_index <> l_exp_index
      THEN
         l_message := 'From program index ' || l_fp_index
            || ' does not match expected index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      IF elements_different ( l_fp_index, l_exp_index )
      THEN
         l_message := 'From program element at index ' || l_fp_index 
                 || ' does not match expected element at index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      l_fp_index := "Value From Function".NEXT ( l_fp_index );
      l_exp_index := "Expected Value From Function".NEXT ( l_exp_index );
   END LOOP;
   
   qu_assert.this ( '{6E3CCAEB-4B93-4A52-98DD-D2DB9D23A27F}', l_message , TRUE);
EXCEPTION
   WHEN different_collections
   THEN
      qu_assert.this ( '{6E3CCAEB-4B93-4A52-98DD-D2DB9D23A27F}', l_message , FALSE);
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
   WHEN OTHERS
   THEN
      qu_assert.report_result ( '{6E3CCAEB-4B93-4A52-98DD-D2DB9D23A27F}', l_message, error_info );
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "One placeholder at beginning of string"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END One_placeholder_at_beginning_o;
       
      PROCEDURE One_placeholder_at_the_end_of_
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
      "Expected Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
         PROCEDURE setup IS
         BEGIN
            -- Qute START CUSTOM SETUP for TESTCASE {0AF46FB4-6446-43FC-951E-B6C1AA3A15D7}
            -- Place all your custom setup code between these START and END comments.
            -- Don't forget to initialize this "expected value" collection!
-- "Expected Value From Function"(N) := VALUE;
"Expected Value From Function"(1).name := 'ABC';
"Expected Value From Function"(1).position := '1';
"Expected Value From Function"(2).name := 'D';
"Expected Value From Function"(2).position := '6';
            -- Qute END CUSTOM SETUP for TESTCASE {0AF46FB4-6446-43FC-951E-B6C1AA3A15D7}
             
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.ALL_IN_STRING(
                  STRING_IN => ':abc :d'
                  ,DYN_PLSQL_IN => NULL
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{0AF46FB4-6446-43FC-951E-B6C1AA3A15D7}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            /*
Before running your test, populate the "Expected Value From Function" collection 
in the test case Initialization section with the data you expect to
see in the "Value From Function" collection.
*/         
DECLARE
   c_match_index_values BOOLEAN := '' = 'Y';
   c_null_ok CONSTANT BOOLEAN := TRUE;
   c_stop_test CONSTANT BOOLEAN := FALSE;
   c_fp_count CONSTANT PLS_INTEGER := "Value From Function".COUNT;
   c_exp_count CONSTANT PLS_INTEGER := "Expected Value From Function".COUNT;
   --
   l_fp_index PLS_INTEGER := NVL (NULL, "Value From Function".FIRST); 
   l_exp_index PLS_INTEGER := NVL (NULL, "Expected Value From Function".FIRST);
   l_fp_last PLS_INTEGER := NVL (NULL, "Value From Function".LAST); 
   l_exp_last PLS_INTEGER := NVL (NULL, "Expected Value From Function".LAST);
   -- 
   l_message VARCHAR2 ( 32767 ) := 'The "from program" and "expected" collections contain the same contents.';
   different_collections EXCEPTION;
   FUNCTION elements_different (fp_index_in IN PLS_INTEGER, exp_index_in IN PLS_INTEGER) RETURN BOOLEAN
   IS BEGIN
      RETURN NOT ( DYN_PLACEHOLDER.EQ ( "Expected Value From Function"  ( exp_index_in )
                               , "Value From Function" ( fp_index_in )
                               , c_null_ok
                               )
                 );
   END elements_different;
BEGIN
   IF c_fp_count <> c_exp_count
   THEN
      l_message :=
            'From program count of ' || c_fp_count
         || ' does not match expected count of ' || c_exp_count;
      RAISE different_collections;
   END IF;
   LOOP
      EXIT WHEN (l_fp_index IS NULL AND l_exp_index IS NULL) 
            OR (l_fp_index > l_fp_last OR l_exp_index > l_exp_last);
      IF c_match_index_values AND l_fp_index <> l_exp_index
      THEN
         l_message := 'From program index ' || l_fp_index
            || ' does not match expected index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      IF elements_different ( l_fp_index, l_exp_index )
      THEN
         l_message := 'From program element at index ' || l_fp_index 
                 || ' does not match expected element at index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      l_fp_index := "Value From Function".NEXT ( l_fp_index );
      l_exp_index := "Expected Value From Function".NEXT ( l_exp_index );
   END LOOP;
   
   qu_assert.this ( '{FFC3B06D-D08E-45F6-B7D3-040A399FFC81}', l_message , TRUE);
EXCEPTION
   WHEN different_collections
   THEN
      qu_assert.this ( '{FFC3B06D-D08E-45F6-B7D3-040A399FFC81}', l_message , FALSE);
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
   WHEN OTHERS
   THEN
      qu_assert.report_result ( '{FFC3B06D-D08E-45F6-B7D3-040A399FFC81}', l_message, error_info );
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "One placeholder at the end of the string"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END One_placeholder_at_the_end_of_;
       
      PROCEDURE Placeholder_with_very_long_nam
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
      "Expected Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
         PROCEDURE setup IS
         BEGIN
            -- Qute START CUSTOM SETUP for TESTCASE {FCB340BC-32FC-4A61-8F86-DF23E77D2AB1}
            -- Place all your custom setup code between these START and END comments.
            -- Don't forget to initialize this "expected value" collection!
-- "Expected Value From Function"(N) := VALUE;
"Expected Value From Function"(1).name := 'DEF';
"Expected Value From Function"(1).position := '5';
"Expected Value From Function"(2).name := 'KRSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA';
"Expected Value From Function"(2).position := '14';
"Expected Value From Function"(3).name := '123';
"Expected Value From Function"(3).position := '71';
"Expected Value From Function"(4).name := 'DEF';
"Expected Value From Function"(4).position := '76';
            -- Qute END CUSTOM SETUP for TESTCASE {FCB340BC-32FC-4A61-8F86-DF23E77D2AB1}
             
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.ALL_IN_STRING(
                  STRING_IN => 'abc :def hij :krsaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa :123 :def'
                  ,DYN_PLSQL_IN => NULL
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{FCB340BC-32FC-4A61-8F86-DF23E77D2AB1}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            /*
Before running your test, populate the "Expected Value From Function" collection 
in the test case Initialization section with the data you expect to
see in the "Value From Function" collection.
*/         
DECLARE
   c_match_index_values BOOLEAN := '' = 'Y';
   c_null_ok CONSTANT BOOLEAN := TRUE;
   c_stop_test CONSTANT BOOLEAN := FALSE;
   c_fp_count CONSTANT PLS_INTEGER := "Value From Function".COUNT;
   c_exp_count CONSTANT PLS_INTEGER := "Expected Value From Function".COUNT;
   --
   l_fp_index PLS_INTEGER := NVL (NULL, "Value From Function".FIRST); 
   l_exp_index PLS_INTEGER := NVL (NULL, "Expected Value From Function".FIRST);
   l_fp_last PLS_INTEGER := NVL (NULL, "Value From Function".LAST); 
   l_exp_last PLS_INTEGER := NVL (NULL, "Expected Value From Function".LAST);
   -- 
   l_message VARCHAR2 ( 32767 ) := 'The "from program" and "expected" collections contain the same contents.';
   different_collections EXCEPTION;
   FUNCTION elements_different (fp_index_in IN PLS_INTEGER, exp_index_in IN PLS_INTEGER) RETURN BOOLEAN
   IS BEGIN
      RETURN NOT ( DYN_PLACEHOLDER.EQ ( "Expected Value From Function"  ( exp_index_in )
                               , "Value From Function" ( fp_index_in )
                               , c_null_ok
                               )
                 );
   END elements_different;
BEGIN
   IF c_fp_count <> c_exp_count
   THEN
      l_message :=
            'From program count of ' || c_fp_count
         || ' does not match expected count of ' || c_exp_count;
      RAISE different_collections;
   END IF;
   LOOP
      EXIT WHEN (l_fp_index IS NULL AND l_exp_index IS NULL) 
            OR (l_fp_index > l_fp_last OR l_exp_index > l_exp_last);
      IF c_match_index_values AND l_fp_index <> l_exp_index
      THEN
         l_message := 'From program index ' || l_fp_index
            || ' does not match expected index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      IF elements_different ( l_fp_index, l_exp_index )
      THEN
         l_message := 'From program element at index ' || l_fp_index 
                 || ' does not match expected element at index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      l_fp_index := "Value From Function".NEXT ( l_fp_index );
      l_exp_index := "Expected Value From Function".NEXT ( l_exp_index );
   END LOOP;
   
   qu_assert.this ( '{EF13CF0B-FE0D-4D30-A732-8C87CDE8D43E}', l_message , TRUE);
EXCEPTION
   WHEN different_collections
   THEN
      qu_assert.this ( '{EF13CF0B-FE0D-4D30-A732-8C87CDE8D43E}', l_message , FALSE);
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
   WHEN OTHERS
   THEN
      qu_assert.report_result ( '{EF13CF0B-FE0D-4D30-A732-8C87CDE8D43E}', l_message, error_info );
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "Placeholder with very long name"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END Placeholder_with_very_long_nam;
       
      PROCEDURE Repeated_placeholders_in_PL_SQ
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
      "Expected Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
         PROCEDURE setup IS
         BEGIN
            -- Qute START CUSTOM SETUP for TESTCASE {18305709-D49C-47D7-BE8D-2A3790947A9E}
            -- Place all your custom setup code between these START and END comments.
            -- Don't forget to initialize this "expected value" collection!
-- "Expected Value From Function"(N) := VALUE;
"Expected Value From Function"(1).name := 'DEF';
"Expected Value From Function"(1).position := '5';
"Expected Value From Function"(2).name := 'KRS';
"Expected Value From Function"(2).position := '14';
"Expected Value From Function"(3).name := '123';
"Expected Value From Function"(3).position := '19';
            -- Qute END CUSTOM SETUP for TESTCASE {18305709-D49C-47D7-BE8D-2A3790947A9E}
             
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.ALL_IN_STRING(
                  STRING_IN => 'abc :def hij :krs :123 :def;'
                  ,DYN_PLSQL_IN => NULL
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{18305709-D49C-47D7-BE8D-2A3790947A9E}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            /*
Before running your test, populate the "Expected Value From Function" collection 
in the test case Initialization section with the data you expect to
see in the "Value From Function" collection.
*/         
DECLARE
   c_match_index_values BOOLEAN := '' = 'Y';
   c_null_ok CONSTANT BOOLEAN := TRUE;
   c_stop_test CONSTANT BOOLEAN := FALSE;
   c_fp_count CONSTANT PLS_INTEGER := "Value From Function".COUNT;
   c_exp_count CONSTANT PLS_INTEGER := "Expected Value From Function".COUNT;
   --
   l_fp_index PLS_INTEGER := NVL (NULL, "Value From Function".FIRST); 
   l_exp_index PLS_INTEGER := NVL (NULL, "Expected Value From Function".FIRST);
   l_fp_last PLS_INTEGER := NVL (NULL, "Value From Function".LAST); 
   l_exp_last PLS_INTEGER := NVL (NULL, "Expected Value From Function".LAST);
   -- 
   l_message VARCHAR2 ( 32767 ) := 'The "from program" and "expected" collections contain the same contents.';
   different_collections EXCEPTION;
   FUNCTION elements_different (fp_index_in IN PLS_INTEGER, exp_index_in IN PLS_INTEGER) RETURN BOOLEAN
   IS BEGIN
      RETURN NOT ( DYN_PLACEHOLDER.EQ ( "Expected Value From Function"  ( exp_index_in )
                               , "Value From Function" ( fp_index_in )
                               , c_null_ok
                               )
                 );
   END elements_different;
BEGIN
   IF c_fp_count <> c_exp_count
   THEN
      l_message :=
            'From program count of ' || c_fp_count
         || ' does not match expected count of ' || c_exp_count;
      RAISE different_collections;
   END IF;
   LOOP
      EXIT WHEN (l_fp_index IS NULL AND l_exp_index IS NULL) 
            OR (l_fp_index > l_fp_last OR l_exp_index > l_exp_last);
      IF c_match_index_values AND l_fp_index <> l_exp_index
      THEN
         l_message := 'From program index ' || l_fp_index
            || ' does not match expected index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      IF elements_different ( l_fp_index, l_exp_index )
      THEN
         l_message := 'From program element at index ' || l_fp_index 
                 || ' does not match expected element at index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      l_fp_index := "Value From Function".NEXT ( l_fp_index );
      l_exp_index := "Expected Value From Function".NEXT ( l_exp_index );
   END LOOP;
   
   qu_assert.this ( '{C7CA08AE-E801-48C5-96E6-C45732D57E00}', l_message , TRUE);
EXCEPTION
   WHEN different_collections
   THEN
      qu_assert.this ( '{C7CA08AE-E801-48C5-96E6-C45732D57E00}', l_message , FALSE);
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
   WHEN OTHERS
   THEN
      qu_assert.report_result ( '{C7CA08AE-E801-48C5-96E6-C45732D57E00}', l_message, error_info );
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "Repeated placeholders in PL/SQL block"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END Repeated_placeholders_in_PL_SQ;
       
      PROCEDURE Repeated_placeholders_in_SQL_s
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
      "Expected Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_AAT;
         PROCEDURE setup IS
         BEGIN
            -- Qute START CUSTOM SETUP for TESTCASE {DAC368CD-59E5-44FB-904A-3A93C76BDA29}
            -- Place all your custom setup code between these START and END comments.
            -- Don't forget to initialize this "expected value" collection!
-- "Expected Value From Function"(N) := VALUE;
"Expected Value From Function"(1).name := 'DEF';
"Expected Value From Function"(1).position := '5';
"Expected Value From Function"(2).name := 'KRS';
"Expected Value From Function"(2).position := '14';
"Expected Value From Function"(3).name := '123';
"Expected Value From Function"(3).position := '19';
"Expected Value From Function"(4).name := 'DEF';
"Expected Value From Function"(4).position := '24';
            -- Qute END CUSTOM SETUP for TESTCASE {DAC368CD-59E5-44FB-904A-3A93C76BDA29}
             
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.ALL_IN_STRING(
                  STRING_IN => 'abc :def hij :krs :123 :def'
                  ,DYN_PLSQL_IN => NULL
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{DAC368CD-59E5-44FB-904A-3A93C76BDA29}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            /*
Before running your test, populate the "Expected Value From Function" collection 
in the test case Initialization section with the data you expect to
see in the "Value From Function" collection.
*/         
DECLARE
   c_match_index_values BOOLEAN := '' = 'Y';
   c_null_ok CONSTANT BOOLEAN := TRUE;
   c_stop_test CONSTANT BOOLEAN := FALSE;
   c_fp_count CONSTANT PLS_INTEGER := "Value From Function".COUNT;
   c_exp_count CONSTANT PLS_INTEGER := "Expected Value From Function".COUNT;
   --
   l_fp_index PLS_INTEGER := NVL (NULL, "Value From Function".FIRST); 
   l_exp_index PLS_INTEGER := NVL (NULL, "Expected Value From Function".FIRST);
   l_fp_last PLS_INTEGER := NVL (NULL, "Value From Function".LAST); 
   l_exp_last PLS_INTEGER := NVL (NULL, "Expected Value From Function".LAST);
   -- 
   l_message VARCHAR2 ( 32767 ) := 'The "from program" and "expected" collections contain the same contents.';
   different_collections EXCEPTION;
   FUNCTION elements_different (fp_index_in IN PLS_INTEGER, exp_index_in IN PLS_INTEGER) RETURN BOOLEAN
   IS BEGIN
      RETURN NOT ( DYN_PLACEHOLDER.EQ ( "Expected Value From Function"  ( exp_index_in )
                               , "Value From Function" ( fp_index_in )
                               , c_null_ok
                               )
                 );
   END elements_different;
BEGIN
   IF c_fp_count <> c_exp_count
   THEN
      l_message :=
            'From program count of ' || c_fp_count
         || ' does not match expected count of ' || c_exp_count;
      RAISE different_collections;
   END IF;
   LOOP
      EXIT WHEN (l_fp_index IS NULL AND l_exp_index IS NULL) 
            OR (l_fp_index > l_fp_last OR l_exp_index > l_exp_last);
      IF c_match_index_values AND l_fp_index <> l_exp_index
      THEN
         l_message := 'From program index ' || l_fp_index
            || ' does not match expected index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      IF elements_different ( l_fp_index, l_exp_index )
      THEN
         l_message := 'From program element at index ' || l_fp_index 
                 || ' does not match expected element at index ' || l_exp_index || '.';
         RAISE different_collections;
      END IF;
      l_fp_index := "Value From Function".NEXT ( l_fp_index );
      l_exp_index := "Expected Value From Function".NEXT ( l_exp_index );
   END LOOP;
   
   qu_assert.this ( '{C3B4FB2F-F862-4776-B3DE-10FB3EF0AB17}', l_message , TRUE);
EXCEPTION
   WHEN different_collections
   THEN
      qu_assert.this ( '{C3B4FB2F-F862-4776-B3DE-10FB3EF0AB17}', l_message , FALSE);
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
   WHEN OTHERS
   THEN
      qu_assert.report_result ( '{C3B4FB2F-F862-4776-B3DE-10FB3EF0AB17}', l_message, error_info );
     IF c_stop_test THEN RAISE PROGRAM_ERROR; END IF;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "Repeated placeholders in SQL string"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END Repeated_placeholders_in_SQL_s;
       
   BEGIN
      DBMS_OUTPUT.PUT_LINE ('QUTE> Testing "ALL_IN_STRING"');
      Assignment_operator_in_string_;
      Multiple_placeholders_in_strin;
      No_placeholders_in_string;
      One_placeholder_at_beginning_o;
      One_placeholder_at_the_end_of_;
      Placeholder_with_very_long_nam;
      Repeated_placeholders_in_PL_SQ;
      Repeated_placeholders_in_SQL_s;
       
      NULL; -- Included to ensure that this procedure will compile if empty.
   END UT_ALL_IN_STRING;
    
   PROCEDURE UT_COUNT_IN_STRING
   -- Unit test procedure for COUNT_IN_STRING
   IS
      PROCEDURE Multiple_and_repeated_PL_SQL
      IS
      -- Return value of function
      "Value From Function" PLS_INTEGER;
      "Expected Value From Function" PLS_INTEGER;
         PROCEDURE setup IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.COUNT_IN_STRING(
                  STRING_IN => 'abc :def hij :krs :123 :def;'
                  ,DYN_PLSQL_IN => TRUE
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{9561653B-375E-49A6-ABAA-494DD112CB0D}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            qu_assert.compare_two_values(
                outcome_guid_in => 'N/A'
               ,operator_in => 'EQ'
               ,check_this_in => "Value From Function"
               ,against_this_in => 3
               ,raise_exc_in => FALSE
               ,null_ok_in => TRUE
               ,truncate_in => FALSE
               );
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "Multiple and repeated, PL/SQL"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END Multiple_and_repeated_PL_SQL;
       
      PROCEDURE Multiple_and_repeated_SQL
      IS
      -- Return value of function
      "Value From Function" PLS_INTEGER;
      "Expected Value From Function" PLS_INTEGER;
         PROCEDURE setup IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.COUNT_IN_STRING(
                  STRING_IN => 'abc :def hij :krs :123 :def'
                  ,DYN_PLSQL_IN => FALSE
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{7176336A-4597-4F0A-AD2B-7B97E73B7AC0}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            qu_assert.compare_two_values(
                outcome_guid_in => 'N/A'
               ,operator_in => 'EQ'
               ,check_this_in => "Value From Function"
               ,against_this_in => 4
               ,raise_exc_in => FALSE
               ,null_ok_in => TRUE
               ,truncate_in => FALSE
               );
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "Multiple and repeated, SQL"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END Multiple_and_repeated_SQL;
       
      PROCEDURE No_placeholders
      IS
      -- Return value of function
      "Value From Function" PLS_INTEGER;
      "Expected Value From Function" PLS_INTEGER;
         PROCEDURE setup IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.COUNT_IN_STRING(
                  STRING_IN => 'abc def'
                  ,DYN_PLSQL_IN => NULL
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{1BC9EF5D-9730-45FF-A06F-9A24FA19476B}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Value returned by function"');
            qu_assert.compare_two_values(
                outcome_guid_in => 'N/A'
               ,operator_in => 'EQ'
               ,check_this_in => "Value From Function"
               ,against_this_in => 0
               ,raise_exc_in => FALSE
               ,null_ok_in => TRUE
               ,truncate_in => FALSE
               );
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "No placeholders"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END No_placeholders;
       
   BEGIN
      DBMS_OUTPUT.PUT_LINE ('QUTE> Testing "COUNT_IN_STRING"');
      Multiple_and_repeated_PL_SQL;
      Multiple_and_repeated_SQL;
      No_placeholders;
       
      NULL; -- Included to ensure that this procedure will compile if empty.
   END UT_COUNT_IN_STRING;
    
   PROCEDURE UT_NTH_IN_STRING
   -- Unit test procedure for NTH_IN_STRING
   IS
      PROCEDURE NO_PLACEHOLDER_IN_STRING
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_RT;
         PROCEDURE setup IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.NTH_IN_STRING(
                  STRING_IN => 'abc def'
                  ,NTH_IN => 1
                  ,DYN_PLSQL_IN => TRUE
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{94DAED1D-AEA7-469F-ACE4-27B8F0EBC02A}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Does the record match the specified query?"');
            DECLARE
   TYPE weak_rc IS REF CURSOR;
   cv_from_source weak_rc;
   
   l_record DYN_PLACEHOLDER.PLACEHOLDER_RT;
   l_result BOOLEAN;
   l_message VARCHAR2 ( 32767 );
   FUNCTION records_equal (rec1 in DYN_PLACEHOLDER.PLACEHOLDER_RT, rec2 in DYN_PLACEHOLDER.PLACEHOLDER_RT) return boolean
   IS BEGIN 
      RETURN
     ((rec1.NAME = rec2.NAME) OR (rec1.NAME IS NULL AND rec2.NAME IS NULL))
AND ((rec1.POSITION = rec2.POSITION) OR (rec1.POSITION IS NULL AND rec2.POSITION IS NULL))
     ;
   END records_equal;
BEGIN
   -- Move contents of control dataset to a nested table.
   -- Notice that only and always the FIRST ROW is fetched.
   -- All other data is ignored. 
   OPEN cv_from_source FOR select null name, null position from dual;
   FETCH cv_from_source INTO l_record;
   CLOSE cv_from_source;
   
   l_result := records_equal ("Value From Function", l_record);
   
   IF l_result
   THEN
      l_message := 'Record from program matches contents of ' || 'select null name, null position from dual';
   ELSE
      l_message := 'Record from program does not match contents of ' || 'select null name, null position from dual';
   END IF;
   qu_assert.this
                ( outcome_guid_in      => '{E3E0EFC8-7A82-41C1-8F85-1234B0F62C0C}'
                , msg_in               => l_message
                , check_this_in        => l_result
                , null_ok_in           => FALSE
                , raise_exc_in         => FALSE
                );
EXCEPTION
   WHEN OTHERS
   THEN
      -- Report the failure.
      qu_assert.report_result ( '{E3E0EFC8-7A82-41C1-8F85-1234B0F62C0C}'
                              , 'RUNTIME-ERROR'
                              , error_info
                              );
      RAISE;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "No placeholder in string"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END NO_PLACEHOLDER_IN_STRING;
       
      PROCEDURE RETURN_FIRST_PLACEHOLDER
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_RT;
         PROCEDURE setup IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.NTH_IN_STRING(
                  STRING_IN => 'abc :def hij :krs :123 :def'
                  ,NTH_IN => 1
                  ,DYN_PLSQL_IN => TRUE
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{711617FE-5127-4F10-9171-7A00F1D402C6}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Does the record match the specified query?"');
            DECLARE
   TYPE weak_rc IS REF CURSOR;
   cv_from_source weak_rc;
   
   l_record DYN_PLACEHOLDER.PLACEHOLDER_RT;
   l_result BOOLEAN;
   l_message VARCHAR2 ( 32767 );
   FUNCTION records_equal (rec1 in DYN_PLACEHOLDER.PLACEHOLDER_RT, rec2 in DYN_PLACEHOLDER.PLACEHOLDER_RT) return boolean
   IS BEGIN 
      RETURN
     ((rec1.NAME = rec2.NAME) OR (rec1.NAME IS NULL AND rec2.NAME IS NULL))
AND ((rec1.POSITION = rec2.POSITION) OR (rec1.POSITION IS NULL AND rec2.POSITION IS NULL))
     ;
   END records_equal;
BEGIN
   -- Move contents of control dataset to a nested table.
   -- Notice that only and always the FIRST ROW is fetched.
   -- All other data is ignored. 
   OPEN cv_from_source FOR select 'DEF' name, 5 position from dual;
   FETCH cv_from_source INTO l_record;
   CLOSE cv_from_source;
   
   l_result := records_equal ("Value From Function", l_record);
   
   IF l_result
   THEN
      l_message := 'Record from program matches contents of ' || 'select ''DEF'' name, 5 position from dual';
   ELSE
      l_message := 'Record from program does not match contents of ' || 'select ''DEF'' name, 5 position from dual';
   END IF;
   qu_assert.this
                ( outcome_guid_in      => '{28AE8DA5-C70A-4E01-9B1D-A38318C8D5DC}'
                , msg_in               => l_message
                , check_this_in        => l_result
                , null_ok_in           => FALSE
                , raise_exc_in         => FALSE
                );
EXCEPTION
   WHEN OTHERS
   THEN
      -- Report the failure.
      qu_assert.report_result ( '{28AE8DA5-C70A-4E01-9B1D-A38318C8D5DC}'
                              , 'RUNTIME-ERROR'
                              , error_info
                              );
      RAISE;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "Return first placeholder"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END RETURN_FIRST_PLACEHOLDER;
       
      PROCEDURE RETURN_THIRD_PLACEHOLDER
      IS
      -- Return value of function
      "Value From Function" DYN_PLACEHOLDER.PLACEHOLDER_RT;
         PROCEDURE setup IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END setup;
          
         PROCEDURE set_in_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_in_values;
          
         PROCEDURE set_expected_values IS
         BEGIN 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;
          
         PROCEDURE call_the_program IS
         BEGIN
         
            "Value From Function" :=
            DYN_PLACEHOLDER.NTH_IN_STRING(
                  STRING_IN => 'abc :def hij :krs :123 :def'
                  ,NTH_IN => 3
                  ,DYN_PLSQL_IN => NULL
            );
            
            EXCEPTION WHEN OTHERS THEN qu_assert.report_result('{C3D1BCFA-CB99-4936-8AB6-03E2CD82D444}', 'RUNTIME-ERROR', error_info);
         END call_the_program;
          
         PROCEDURE check_out_args_and_return IS
         BEGIN
            DBMS_OUTPUT.PUT_LINE ('QUTE>    Outcome "Does the record match the specified query?"');
            DECLARE
   TYPE weak_rc IS REF CURSOR;
   cv_from_source weak_rc;
   
   l_record DYN_PLACEHOLDER.PLACEHOLDER_RT;
   l_result BOOLEAN;
   l_message VARCHAR2 ( 32767 );
   FUNCTION records_equal (rec1 in DYN_PLACEHOLDER.PLACEHOLDER_RT, rec2 in DYN_PLACEHOLDER.PLACEHOLDER_RT) return boolean
   IS BEGIN 
      RETURN
     ((rec1.NAME = rec2.NAME) OR (rec1.NAME IS NULL AND rec2.NAME IS NULL))
AND ((rec1.POSITION = rec2.POSITION) OR (rec1.POSITION IS NULL AND rec2.POSITION IS NULL))
     ;
   END records_equal;
BEGIN
   -- Move contents of control dataset to a nested table.
   -- Notice that only and always the FIRST ROW is fetched.
   -- All other data is ignored. 
   OPEN cv_from_source FOR select '123' name, 19 position from dual;
   FETCH cv_from_source INTO l_record;
   CLOSE cv_from_source;
   
   l_result := records_equal ("Value From Function", l_record);
   
   IF l_result
   THEN
      l_message := 'Record from program matches contents of ' || 'select ''123'' name, 19 position from dual';
   ELSE
      l_message := 'Record from program does not match contents of ' || 'select ''123'' name, 19 position from dual';
   END IF;
   qu_assert.this
                ( outcome_guid_in      => '{3C6FA245-8DFF-48D6-A27D-01ABBDCDA950}'
                , msg_in               => l_message
                , check_this_in        => l_result
                , null_ok_in           => FALSE
                , raise_exc_in         => FALSE
                );
EXCEPTION
   WHEN OTHERS
   THEN
      -- Report the failure.
      qu_assert.report_result ( '{3C6FA245-8DFF-48D6-A27D-01ABBDCDA950}'
                              , 'RUNTIME-ERROR'
                              , error_info
                              );
      RAISE;
END;
 
            NULL; -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;
          
         PROCEDURE teardown IS
         BEGIN
            NULL; -- Included to ensure that this procedure will compile if empty.
         END teardown;
          
      BEGIN
         DBMS_OUTPUT.PUT_LINE ('QUTE>  Test case "Return third placeholder"');
         setup;
          
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
          
         teardown;
          
      END RETURN_THIRD_PLACEHOLDER;
       
   BEGIN
      DBMS_OUTPUT.PUT_LINE ('QUTE> Testing "NTH_IN_STRING"');
      NO_PLACEHOLDER_IN_STRING;
      RETURN_FIRST_PLACEHOLDER;
      RETURN_THIRD_PLACEHOLDER;
       
      NULL; -- Included to ensure that this procedure will compile if empty.
   END UT_NTH_IN_STRING;
    
   PROCEDURE run_all_tests IS BEGIN
      qu_assert.set_current_harness_info (NULL, TRUE);
      UT_setup;
      UT_ALL_IN_STRING;
      UT_COUNT_IN_STRING;
      UT_NTH_IN_STRING;
      UT_teardown;
      qu_assert.set_current_harness_info (NULL, NULL);
   END run_all_tests;
END UT_DYN_PLACEHOLDER;

/
