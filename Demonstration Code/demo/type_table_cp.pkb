CREATE OR REPLACE PACKAGE BODY type_table_cp
/*
| Generated by or retrieved from Qnxo - DO NOT MODIFY!
| Qnxo - "Get it right, do it fast" - www.qnxo.com
| Qnxo Universal ID: {657BD35E-2E48-4CD4-B14E-41420B8433B3}
| Created On: June      29, 2005 00:27:56 Created By: QNXO_DEMO
*/
IS
   e_null_column_value           EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_null_column_value, -1400);
   --
   e_existing_fky_reference      EXCEPTION;
   en_existing_fky_reference     PLS_INTEGER DEFAULT -2266;
   PRAGMA EXCEPTION_INIT (e_existing_fky_reference, -2266);
   --
   e_check_constraint_failure    EXCEPTION;
   en_check_constraint_failure   PLS_INTEGER DEFAULT -2290;
   PRAGMA EXCEPTION_INIT (e_check_constraint_failure, -2290);
   --
   e_no_parent_key               EXCEPTION;
   en_no_parent_key              PLS_INTEGER DEFAULT -2291;
   PRAGMA EXCEPTION_INIT (e_no_parent_key, -2291);
   --
   e_child_record_found          EXCEPTION;
   en_child_record_found         PLS_INTEGER DEFAULT -2292;
   PRAGMA EXCEPTION_INIT (e_child_record_found, -2292);
   --
   e_forall_error                EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_forall_error, -24381);
   --
   -- Defined for backward compatibilty.
   e_integ_constraint_failure    EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_integ_constraint_failure, -2291);

   -- Private utilities
   PROCEDURE get_constraint_info (
      owner_out   OUT   all_constraints.owner%TYPE
     ,name_out    OUT   all_constraints.constraint_name%TYPE
   )
   IS
      l_errm    VARCHAR2 (2000)         := DBMS_UTILITY.format_error_stack;
      dotloc    INTEGER;
      leftloc   INTEGER;
      l_owner   all_constraints.owner%TYPE;
      l_name    all_constraints.constraint_name%TYPE;
   BEGIN
      dotloc := INSTR (l_errm, '.');
      leftloc := INSTR (l_errm, '(');
      owner_out := SUBSTR (l_errm, leftloc + 1, dotloc - leftloc - 1);
      name_out :=
              SUBSTR (l_errm, dotloc + 1, INSTR (l_errm, ')') - dotloc - 1);
   END get_constraint_info;

   -- Public programs
   PROCEDURE ins (
      id_in             IN   type_table_tp.id_t
     ,category_in       IN   type_table_tp.category_t DEFAULT NULL
     ,NAME_IN           IN   type_table_tp.name_t DEFAULT NULL
     ,description_in    IN   type_table_tp.description_t DEFAULT NULL
     ,is_default_in     IN   type_table_tp.is_default_t DEFAULT 'N'
     ,handle_error_in   IN   BOOLEAN := TRUE
   )
   IS
   BEGIN
      INSERT INTO type_table
                  (ID, CATEGORY, NAME, description
                  ,is_default
                  )
           VALUES (id_in, category_in, NAME_IN, description_in
                  ,is_default_in
                  );
   END ins;

   PROCEDURE ins (
      rec_in            IN   type_table_tp.type_table_rt
     ,gen_pky_in        IN   BOOLEAN DEFAULT FALSE
     ,sequence_in       IN   VARCHAR2 := NULL
     ,handle_error_in   IN   BOOLEAN := TRUE
   )
   IS
      l_rec   type_table_tp.type_table_rt := rec_in;
   BEGIN
      IF gen_pky_in
      THEN
         l_rec.ID := NEXT_KEY (sequence_in);
      END IF;

      ins (id_in                => l_rec.ID
          ,category_in          => l_rec.CATEGORY
          ,NAME_IN              => l_rec.NAME
          ,description_in       => l_rec.description
          ,is_default_in        => l_rec.is_default
          ,handle_error_in      => handle_error_in
          );
   END ins;

   FUNCTION NEXT_KEY (sequence_in IN VARCHAR2 := NULL)
      RETURN type_table_tp.id_t
   IS
      retval   type_table_tp.id_t;
   BEGIN
      IF sequence_in IS NULL
      THEN
         SELECT type_table_seq.NEXTVAL
           INTO retval
           FROM DUAL;
      ELSE
         EXECUTE IMMEDIATE 'SELECT ' || sequence_in
                           || '.NEXTVAL FROM dual'
                      INTO retval;
      END IF;

      RETURN retval;
   END NEXT_KEY;

   PROCEDURE ins (
      category_in       IN       type_table_tp.category_t DEFAULT NULL
     ,NAME_IN           IN       type_table_tp.name_t DEFAULT NULL
     ,description_in    IN       type_table_tp.description_t DEFAULT NULL
     ,is_default_in     IN       type_table_tp.is_default_t DEFAULT 'N'
     ,id_out            IN OUT   type_table_tp.id_t
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
      l_pky   type_table_tp.id_t := NEXT_KEY;
   BEGIN
      ins (id_in                => l_pky
          ,category_in          => category_in
          ,NAME_IN              => NAME_IN
          ,description_in       => description_in
          ,is_default_in        => is_default_in
          ,handle_error_in      => handle_error_in
          );
      id_out := l_pky;
   END ins;

   FUNCTION ins (
      category_in       IN   type_table_tp.category_t DEFAULT NULL
     ,NAME_IN           IN   type_table_tp.name_t DEFAULT NULL
     ,description_in    IN   type_table_tp.description_t DEFAULT NULL
     ,is_default_in     IN   type_table_tp.is_default_t DEFAULT 'N'
     ,handle_error_in   IN   BOOLEAN := TRUE
   )
      RETURN type_table_tp.id_t
   IS
      l_pky   type_table_tp.id_t := NEXT_KEY;
   BEGIN
      ins (id_in                => l_pky
          ,category_in          => category_in
          ,NAME_IN              => NAME_IN
          ,description_in       => description_in
          ,is_default_in        => is_default_in
          ,handle_error_in      => handle_error_in
          );
      RETURN l_pky;
   END ins;

   PROCEDURE ins (
      category_in       IN   type_table_tp.category_t DEFAULT NULL
     ,NAME_IN           IN   type_table_tp.name_t DEFAULT NULL
     ,description_in    IN   type_table_tp.description_t DEFAULT NULL
     ,is_default_in     IN   type_table_tp.is_default_t DEFAULT 'N'
     ,handle_error_in   IN   BOOLEAN := TRUE
   )
   IS
      l_pky   type_table_tp.id_t := NEXT_KEY;
   BEGIN
      ins (id_in                => l_pky
          ,category_in          => category_in
          ,NAME_IN              => NAME_IN
          ,description_in       => description_in
          ,is_default_in        => is_default_in
          ,handle_error_in      => handle_error_in
          );
   END ins;

   PROCEDURE ins (
      rows_in           IN       type_table_tp.type_table_tc
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
      l_id            type_table_tp.id_cc;
      l_category      type_table_tp.category_cc;
      l_name          type_table_tp.name_cc;
      l_description   type_table_tp.description_cc;
      l_is_default    type_table_tp.is_default_cc;
      l_progress      VARCHAR2 (1000);
   BEGIN
      IF rows_in.COUNT = 0
      THEN
         rows_out := 0;
      ELSE
         l_progress := 'Populate l_id collection';

         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying ID to column collection row ' || indx;
            l_id (indx) := rows_in (indx).ID;
         END LOOP;

         l_progress := 'Populate l_category collection';

         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress :=
                      'Copying CATEGORY to column collection row ' || indx;
            l_category (indx) := rows_in (indx).CATEGORY;
         END LOOP;

         l_progress := 'Populate l_name collection';

         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress := 'Copying NAME to column collection row ' || indx;
            l_name (indx) := rows_in (indx).NAME;
         END LOOP;

         l_progress := 'Populate l_description collection';

         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress :=
                   'Copying DESCRIPTION to column collection row ' || indx;
            l_description (indx) := rows_in (indx).description;
         END LOOP;

         l_progress := 'Populate l_is_default collection';

         FOR indx IN rows_in.FIRST .. rows_in.LAST
         LOOP
            l_progress :=
                    'Copying IS_DEFAULT to column collection row ' || indx;
            l_is_default (indx) := rows_in (indx).is_default;
         END LOOP;

         l_progress := 'Execute FORALL for ' || rows_in.COUNT || ' rows';
         FORALL indx IN rows_in.FIRST .. rows_in.LAST SAVE EXCEPTIONS
            INSERT INTO type_table
                        (ID, CATEGORY, NAME
                        ,description, is_default
                        )
                 VALUES (l_id (indx), l_category (indx), l_name (indx)
                        ,l_description (indx), l_is_default (indx)
                        );
         l_id.DELETE;
         l_category.DELETE;
         l_name.DELETE;
         l_description.DELETE;
         l_is_default.DELETE;
         rows_out := SQL%ROWCOUNT;
      END IF;
   END ins;

   PROCEDURE upd (
      id_in               IN       type_table_tp.id_t
     ,category_in         IN       type_table_tp.category_t DEFAULT NULL
     ,NAME_IN             IN       type_table_tp.name_t DEFAULT NULL
     ,description_in      IN       type_table_tp.description_t DEFAULT NULL
     ,is_default_in       IN       type_table_tp.is_default_t DEFAULT NULL
     ,rows_out            OUT      PLS_INTEGER
     ,ignore_if_null_in   IN       BOOLEAN := FALSE
     ,handle_error_in     IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      IF NVL (ignore_if_null_in, FALSE)
      THEN
         -- Set any columns to their current values
         -- if incoming value is NULL.
         -- Put WHEN clause on column-level triggers!
         UPDATE type_table
            SET CATEGORY = NVL (category_in, CATEGORY)
               ,NAME = NVL (NAME_IN, NAME)
               ,description = NVL (description_in, description)
               ,is_default = NVL (is_default_in, is_default)
          WHERE ID = id_in;
      ELSE
         UPDATE type_table
            SET CATEGORY = category_in
               ,NAME = NAME_IN
               ,description = description_in
               ,is_default = is_default_in
          WHERE ID = id_in;
      END IF;

      rows_out := SQL%ROWCOUNT;
   END upd;

   PROCEDURE upd (
      rec_in              IN       type_table_tp.type_table_rt
     ,rows_out            OUT      PLS_INTEGER
     ,ignore_if_null_in   IN       BOOLEAN := FALSE
     ,handle_error_in     IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      upd (id_in                  => rec_in.ID
          ,category_in            => rec_in.CATEGORY
          ,NAME_IN                => rec_in.NAME
          ,description_in         => rec_in.description
          ,is_default_in          => rec_in.is_default
          ,rows_out               => rows_out
          ,ignore_if_null_in      => ignore_if_null_in
          ,handle_error_in        => handle_error_in
          );
   END upd;

   PROCEDURE upd_ins (
      id_in               IN       type_table_tp.id_t
     ,category_in         IN       type_table_tp.category_t DEFAULT NULL
     ,NAME_IN             IN       type_table_tp.name_t DEFAULT NULL
     ,description_in      IN       type_table_tp.description_t DEFAULT NULL
     ,is_default_in       IN       type_table_tp.is_default_t DEFAULT NULL
     ,rows_out            OUT      PLS_INTEGER
     ,ignore_if_null_in   IN       BOOLEAN := FALSE
     ,handle_error_in     IN       BOOLEAN := TRUE
   )
   IS
      l_rows   PLS_INTEGER;
   BEGIN
      upd (id_in                  => id_in
          ,category_in            => category_in
          ,NAME_IN                => NAME_IN
          ,description_in         => description_in
          ,is_default_in          => is_default_in
          ,rows_out               => l_rows
          ,ignore_if_null_in      => ignore_if_null_in
          ,handle_error_in        => handle_error_in
          );

      IF l_rows = 0
      THEN
         ins (id_in                => id_in
             ,category_in          => category_in
             ,NAME_IN              => NAME_IN
             ,description_in       => description_in
             ,is_default_in        => is_default_in
             ,handle_error_in      => handle_error_in
             );
         l_rows := 1;
      END IF;

      rows_out := l_rows;
   END upd_ins;

   FUNCTION dynupdstr (
      colname_in   IN   all_tab_columns.column_name%TYPE
     ,where_in     IN   VARCHAR2 := NULL
   )
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN    'UPDATE TYPE_TABLE
             SET '
             || colname_in
             || ' = :value
           WHERE '
             || NVL (where_in, '1=1');
   END dynupdstr;

   PROCEDURE upd_onecol (
      colname_in        IN       all_tab_columns.column_name%TYPE
     ,new_value_in      IN       VARCHAR2
     ,where_in          IN       VARCHAR2 := NULL
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dynupdstr (colname_in, where_in)
                  USING new_value_in;

      rows_out := SQL%ROWCOUNT;
   END upd_onecol;

   PROCEDURE upd_onecol (
      colname_in        IN       all_tab_columns.column_name%TYPE
     ,new_value_in      IN       DATE
     ,where_in          IN       VARCHAR2 := NULL
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dynupdstr (colname_in, where_in)
                  USING new_value_in;

      rows_out := SQL%ROWCOUNT;
   END upd_onecol;

   PROCEDURE upd_onecol (
      colname_in        IN       all_tab_columns.column_name%TYPE
     ,new_value_in      IN       NUMBER
     ,where_in          IN       VARCHAR2 := NULL
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dynupdstr (colname_in, where_in)
                  USING new_value_in;

      rows_out := SQL%ROWCOUNT;
   END upd_onecol;

   PROCEDURE upd_onecol_pky (
      colname_in        IN       all_tab_columns.column_name%TYPE
     ,new_value_in      IN       VARCHAR2
     ,id_in             IN       type_table_tp.id_t
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
      l_colname   all_tab_columns.column_name%TYPE   := UPPER (colname_in);
   BEGIN
      IF l_colname = 'CATEGORY'
      THEN
         UPDATE type_table
            SET CATEGORY = new_value_in
          WHERE ID = id_in;

         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;

      IF l_colname = 'NAME'
      THEN
         UPDATE type_table
            SET NAME = new_value_in
          WHERE ID = id_in;

         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;

      IF l_colname = 'DESCRIPTION'
      THEN
         UPDATE type_table
            SET description = new_value_in
          WHERE ID = id_in;

         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;

      IF l_colname = 'IS_DEFAULT'
      THEN
         UPDATE type_table
            SET is_default = new_value_in
          WHERE ID = id_in;

         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;

      <<update_complete>>
      rows_out := SQL%ROWCOUNT;
   END upd_onecol_pky;

   PROCEDURE upd_onecol_pky (
      colname_in        IN       all_tab_columns.column_name%TYPE
     ,new_value_in      IN       NUMBER
     ,id_in             IN       type_table_tp.id_t
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
      l_colname   all_tab_columns.column_name%TYPE   := UPPER (colname_in);
   BEGIN
      IF l_colname = 'ID'
      THEN
         UPDATE type_table
            SET ID = new_value_in
          WHERE ID = id_in;

         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;

      <<update_complete>>
      rows_out := SQL%ROWCOUNT;
   END upd_onecol_pky;

   -- Set all non-primary key columns to NULL
   PROCEDURE nullify_row (
      id_in             IN   type_table_tp.id_t
     ,handle_error_in   IN   BOOLEAN := TRUE
   )
   IS
      l_rows   PLS_INTEGER;
   BEGIN
      upd (id_in                  => id_in
          ,description_in         => NULL
          ,is_default_in          => NULL
          ,rows_out               => l_rows
          ,ignore_if_null_in      => FALSE
          ,handle_error_in        => handle_error_in
          );
   END nullify_row;

   -- Delete functionality
   PROCEDURE del (
      id_in             IN       type_table_tp.id_t
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      DELETE FROM type_table
            WHERE ID = id_in;

      rows_out := SQL%ROWCOUNT;
   END del;

   -- Delete all rows for primary key column ID
   PROCEDURE del_id (
      id_in             IN       type_table_tp.id_t
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      DELETE FROM type_table
            WHERE ID = id_in;

      rows_out := SQL%ROWCOUNT;
   END del_id;

   -- Delete for unique value of UN_TYPE_TABLE
   PROCEDURE del_un_type_table (
      category_in       IN       type_table_tp.category_t
     ,NAME_IN           IN       type_table_tp.name_t
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      DELETE FROM type_table
            WHERE CATEGORY = category_in AND NAME = NAME_IN;

      rows_out := SQL%ROWCOUNT;
   END del_un_type_table;

   -- Deletions using dynamic SQL
   FUNCTION dyndelstr (where_in IN VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      IF where_in IS NULL
      THEN
         RETURN 'DELETE FROM TYPE_TABLE';
      ELSE
         RETURN 'DELETE FROM TYPE_TABLE WHERE ' || where_in;
      END IF;
   END dyndelstr;

   FUNCTION dyncoldelstr (colname_in IN all_tab_columns.column_name%TYPE)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN dyndelstr (colname_in || ' = :value');
   END;

   PROCEDURE del_by (
      where_clause_in   IN       VARCHAR2
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dyndelstr (where_clause_in);

      rows_out := SQL%ROWCOUNT;
   END del_by;

   PROCEDURE del_by_col (
      colname_in        IN       VARCHAR2
     ,colvalue_in       IN       VARCHAR2
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dyncoldelstr (colname_in)
                  USING colvalue_in;

      rows_out := SQL%ROWCOUNT;
   END del_by_col;

   PROCEDURE del_by_col (
      colname_in        IN       VARCHAR2
     ,colvalue_in       IN       DATE
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dyncoldelstr (colname_in)
                  USING colvalue_in;

      rows_out := SQL%ROWCOUNT;
   END del_by_col;

   PROCEDURE del_by_col (
      colname_in        IN       VARCHAR2
     ,colvalue_in       IN       NUMBER
     ,rows_out          OUT      PLS_INTEGER
     ,handle_error_in   IN       BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dyncoldelstr (colname_in)
                  USING colvalue_in;

      rows_out := SQL%ROWCOUNT;
   END del_by_col;
BEGIN
   NULL;
END type_table_cp;
/