CREATE OR REPLACE PACKAGE BODY EMPLOYEES_CP
/*
| Generated by or retrieved from QCGU - DO NOT MODIFY!
| QCGU - "Get it right, do it fast" - www.ToadWorld.com
| QCGU Universal ID: {657BD35E-2E48-4CD4-B14E-41420B8433B3}
| Created On: October 14, 2011 6:44:26
| Created By: QCGU
*/
IS

   e_null_column_value EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_null_column_value, -1400);
   --
   e_existing_fky_reference EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_existing_fky_reference, -2266);
   --
   e_check_constraint_failure EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_check_constraint_failure, -2290);
   --
   e_no_parent_key EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_no_parent_key, -2291);
   --
   e_child_record_found EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_child_record_found, -2292);
   --
   e_forall_error EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_forall_error, -24381);
   --
   -- Defined for backward compatibilty.
   e_integ_constraint_failure EXCEPTION;
   PRAGMA EXCEPTION_INIT (e_integ_constraint_failure, -2291);

    -- Private utilities
   PROCEDURE get_constraint_info (
      owner_out OUT ALL_CONSTRAINTS.OWNER%TYPE
     ,name_out OUT ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE)
   IS
      l_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
      dotloc PLS_INTEGER;
      leftloc PLS_INTEGER;
   BEGIN
      dotloc  := INSTR (l_errm,'.');
      leftloc := INSTR (l_errm,'(');
      owner_out := SUBSTR (l_errm, leftloc+1, dotloc-leftloc-1);
      name_out  := SUBSTR (l_errm, dotloc+1, INSTR (l_errm,')')-dotloc-1);
   END get_constraint_info;
   -- Public programs

   PROCEDURE ins (
      employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t
      ,
      first_name_in IN EMPLOYEES_TP.FIRST_NAME_t DEFAULT NULL,
      last_name_in IN EMPLOYEES_TP.LAST_NAME_t DEFAULT NULL,
      email_in IN EMPLOYEES_TP.EMAIL_t DEFAULT NULL,
      phone_number_in IN EMPLOYEES_TP.PHONE_NUMBER_t DEFAULT NULL,
      hire_date_in IN EMPLOYEES_TP.HIRE_DATE_t DEFAULT NULL,
      job_id_in IN EMPLOYEES_TP.JOB_ID_t DEFAULT NULL,
      salary_in IN EMPLOYEES_TP.SALARY_t DEFAULT NULL,
      commission_pct_in IN EMPLOYEES_TP.COMMISSION_PCT_t DEFAULT NULL,
      manager_id_in IN EMPLOYEES_TP.MANAGER_ID_t DEFAULT NULL,
      department_id_in IN EMPLOYEES_TP.DEPARTMENT_ID_t DEFAULT NULL
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
     INSERT INTO EMPLOYEES (
         EMPLOYEE_ID,
         FIRST_NAME,
         LAST_NAME,
         EMAIL,
         PHONE_NUMBER,
         HIRE_DATE,
         JOB_ID,
         SALARY,
         COMMISSION_PCT,
         MANAGER_ID,
         DEPARTMENT_ID
         )
      VALUES (
         employee_id_in,
         first_name_in,
         last_name_in,
         email_in,
         phone_number_in,
         hire_date_in,
         job_id_in,
         salary_in,
         commission_pct_in,
         manager_id_in,
         department_id_in
         );
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id PLS_INTEGER;
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF FALSE THEN NULL; -- Placeholder in case no unique indexes
           ELSIF l_name = 'EMP_EMAIL_UK'
           THEN
              q$error_manager.register_error (
                 error_name_in => 'DUPLICATE-VALUE'
                ,err_instance_id_out => l_err_instance_id
                ,text_in => 'Violation of unique index "EMP_EMAIL_UK"'
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'OWNER'
                ,value_in => l_owner
                ,validate_in => FALSE
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'CONSTRAINT_NAME'
                ,value_in => l_name
                ,validate_in => FALSE
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'TABLE_NAME'
                ,value_in => 'EMPLOYEES'
                ,validate_in => FALSE
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'EMAIL'
                ,value_in => email_in
                ,validate_in => FALSE
                );
              q$error_manager.raise_error_instance (
                    err_instance_id_in => l_err_instance_id);
           ELSE
              q$error_manager.raise_error (
                    error_name_in => 'DUPLICATE-VALUE'
                    ,name1_in => 'OWNER'
                    ,value1_in => l_owner
                    ,name2_in => 'CONSTRAINT_NAME'
                    ,value2_in => l_name
                    ,name3_in => 'TABLE_NAME'
                    ,value3_in => 'EMPLOYEES');
           END IF;
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           IF l_name = 'EMP_DEPT_FK'
           THEN
              -- Add a context value for each column
              q$error_manager.add_context (
                 err_instance_id_in => l_id
               , name_in => 'DEPARTMENT_ID'
               , value_in => department_id_in);
           END IF;
           IF l_name = 'EMP_JOB_FK'
           THEN
              -- Add a context value for each column
              q$error_manager.add_context (
                 err_instance_id_in => l_id
               , name_in => 'JOB_ID'
               , value_in => job_id_in);
           END IF;
           IF l_name = 'EMP_MANAGER_FK'
           THEN
              -- Add a context value for each column
              q$error_manager.add_context (
                 err_instance_id_in => l_id
               , name_in => 'MANAGER_ID'
               , value_in => manager_id_in);
           END IF;
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           q$error_manager.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
   END ins;


   PROCEDURE ins (
      rec_in IN EMPLOYEES_TP.EMPLOYEES_rt
     ,gen_pky_in IN BOOLEAN DEFAULT FALSE
     ,sequence_in IN VARCHAR2 := NULL
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_rec EMPLOYEES_TP.EMPLOYEES_rt := rec_in;
   BEGIN
      IF gen_pky_in THEN
         l_rec.EMPLOYEE_ID := next_key (sequence_in);
      END IF;
      ins (
         employee_id_in => l_rec.EMPLOYEE_ID
         ,
         first_name_in => l_rec.FIRST_NAME,
         last_name_in => l_rec.LAST_NAME,
         email_in => l_rec.EMAIL,
         phone_number_in => l_rec.PHONE_NUMBER,
         hire_date_in => l_rec.HIRE_DATE,
         job_id_in => l_rec.JOB_ID,
         salary_in => l_rec.SALARY,
         commission_pct_in => l_rec.COMMISSION_PCT,
         manager_id_in => l_rec.MANAGER_ID,
         department_id_in => l_rec.DEPARTMENT_ID
         ,handle_error_in => handle_error_in
         );
   END ins;

   FUNCTION next_key (sequence_in IN VARCHAR2 := NULL) RETURN EMPLOYEES_TP.EMPLOYEE_ID_t
   IS
      retval EMPLOYEES_TP.EMPLOYEE_ID_t;
   BEGIN
      IF sequence_in IS NULL
      THEN
         SELECT employees_seq.NEXTVAL INTO retval FROM dual;
      ELSE
         EXECUTE IMMEDIATE
            'SELECT ' || sequence_in || '.NEXTVAL FROM dual'
            INTO retval;
      END IF;
      RETURN retval;
   EXCEPTION
      WHEN OTHERS THEN
        q$error_manager.raise_error (
           error_name_in => 'SEQUENCE-GENERATION-FAILURE'
           ,name1_in => 'SEQUENCE'
           ,value1_in => NVL (sequence_in, 'employees_seq')
           );
   END next_key;

   PROCEDURE ins (
      first_name_in IN EMPLOYEES_TP.FIRST_NAME_t DEFAULT NULL,
      last_name_in IN EMPLOYEES_TP.LAST_NAME_t DEFAULT NULL,
      email_in IN EMPLOYEES_TP.EMAIL_t DEFAULT NULL,
      phone_number_in IN EMPLOYEES_TP.PHONE_NUMBER_t DEFAULT NULL,
      hire_date_in IN EMPLOYEES_TP.HIRE_DATE_t DEFAULT NULL,
      job_id_in IN EMPLOYEES_TP.JOB_ID_t DEFAULT NULL,
      salary_in IN EMPLOYEES_TP.SALARY_t DEFAULT NULL,
      commission_pct_in IN EMPLOYEES_TP.COMMISSION_PCT_t DEFAULT NULL,
      manager_id_in IN EMPLOYEES_TP.MANAGER_ID_t DEFAULT NULL,
      department_id_in IN EMPLOYEES_TP.DEPARTMENT_ID_t DEFAULT NULL,
      employee_id_out IN OUT EMPLOYEES_TP.EMPLOYEE_ID_t
      ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_pky EMPLOYEES_TP.EMPLOYEE_ID_t := next_key;
   BEGIN
      ins (
         employee_id_in => l_pky,
         first_name_in => first_name_in,
         last_name_in => last_name_in,
         email_in => email_in,
         phone_number_in => phone_number_in,
         hire_date_in => hire_date_in,
         job_id_in => job_id_in,
         salary_in => salary_in,
         commission_pct_in => commission_pct_in,
         manager_id_in => manager_id_in,
         department_id_in => department_id_in
         ,handle_error_in => handle_error_in
         );
      employee_id_out := l_pky;
   END ins;

   FUNCTION ins (
      first_name_in IN EMPLOYEES_TP.FIRST_NAME_t DEFAULT NULL,
      last_name_in IN EMPLOYEES_TP.LAST_NAME_t DEFAULT NULL,
      email_in IN EMPLOYEES_TP.EMAIL_t DEFAULT NULL,
      phone_number_in IN EMPLOYEES_TP.PHONE_NUMBER_t DEFAULT NULL,
      hire_date_in IN EMPLOYEES_TP.HIRE_DATE_t DEFAULT NULL,
      job_id_in IN EMPLOYEES_TP.JOB_ID_t DEFAULT NULL,
      salary_in IN EMPLOYEES_TP.SALARY_t DEFAULT NULL,
      commission_pct_in IN EMPLOYEES_TP.COMMISSION_PCT_t DEFAULT NULL,
      manager_id_in IN EMPLOYEES_TP.MANAGER_ID_t DEFAULT NULL,
      department_id_in IN EMPLOYEES_TP.DEPARTMENT_ID_t DEFAULT NULL
      ,handle_error_in IN BOOLEAN := TRUE
   )
      RETURN
         EMPLOYEES_TP.EMPLOYEE_ID_t
   IS
      l_pky EMPLOYEES_TP.EMPLOYEE_ID_t := next_key;
   BEGIN
      ins (
         employee_id_in => l_pky,
         first_name_in => first_name_in,
         last_name_in => last_name_in,
         email_in => email_in,
         phone_number_in => phone_number_in,
         hire_date_in => hire_date_in,
         job_id_in => job_id_in,
         salary_in => salary_in,
         commission_pct_in => commission_pct_in,
         manager_id_in => manager_id_in,
         department_id_in => department_id_in
         ,handle_error_in => handle_error_in
         );
      RETURN l_pky;
   END ins;

   PROCEDURE ins (
      first_name_in IN EMPLOYEES_TP.FIRST_NAME_t DEFAULT NULL,
      last_name_in IN EMPLOYEES_TP.LAST_NAME_t DEFAULT NULL,
      email_in IN EMPLOYEES_TP.EMAIL_t DEFAULT NULL,
      phone_number_in IN EMPLOYEES_TP.PHONE_NUMBER_t DEFAULT NULL,
      hire_date_in IN EMPLOYEES_TP.HIRE_DATE_t DEFAULT NULL,
      job_id_in IN EMPLOYEES_TP.JOB_ID_t DEFAULT NULL,
      salary_in IN EMPLOYEES_TP.SALARY_t DEFAULT NULL,
      commission_pct_in IN EMPLOYEES_TP.COMMISSION_PCT_t DEFAULT NULL,
      manager_id_in IN EMPLOYEES_TP.MANAGER_ID_t DEFAULT NULL,
      department_id_in IN EMPLOYEES_TP.DEPARTMENT_ID_t DEFAULT NULL
      ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_pky EMPLOYEES_TP.EMPLOYEE_ID_t := next_key;
   BEGIN
      ins (
         employee_id_in => l_pky,
         first_name_in => first_name_in,
         last_name_in => last_name_in,
         email_in => email_in,
         phone_number_in => phone_number_in,
         hire_date_in => hire_date_in,
         job_id_in => job_id_in,
         salary_in => salary_in,
         commission_pct_in => commission_pct_in,
         manager_id_in => manager_id_in,
         department_id_in => department_id_in
         ,handle_error_in => handle_error_in
         );
   END ins;

    PROCEDURE ins (
      rows_in IN EMPLOYEES_TP.EMPLOYEES_tc
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      IF rows_in.COUNT = 0
      THEN
         NULL;
      ELSE
         FORALL indx IN rows_in.FIRST .. rows_in.LAST
            SAVE EXCEPTIONS
            INSERT INTO EMPLOYEES VALUES rows_in (indx);
      END IF;
   EXCEPTION
     WHEN e_forall_error
     THEN
        -- In Oracle9i and above, SAVE EXCEPTIONS will direct control
        -- here if any error occurs. We can then save all the error
        -- information out to the error instance.
       IF NOT handle_error_in THEN RAISE;
       ELSE
          <<bulk_handler>>
          DECLARE
             l_err_instance_id NUMBER;
          BEGIN
             -- For each error, write to the log.
             FOR indx IN 1 .. SQL%BULK_EXCEPTIONS.COUNT
             LOOP
                q$error_manager.register_error (
                    error_name_in => 'FORALL-INSERT-FAILURE'
                   ,err_instance_id_out => l_err_instance_id
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'BINDING_ROW_' || indx
                  ,value_in => SQL%BULK_EXCEPTIONS (indx).ERROR_INDEX
                  ,validate_in => FALSE
                );
                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'ERROR_AT_ROW_' || indx
                  ,value_in => SQL%BULK_EXCEPTIONS (indx).ERROR_CODE
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'EMPLOYEE_ID _' || indx
                  ,value_in => rows_in(indx).EMPLOYEE_ID
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'FIRST_NAME _' || indx
                  ,value_in => rows_in(indx).FIRST_NAME
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'LAST_NAME _' || indx
                  ,value_in => rows_in(indx).LAST_NAME
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'EMAIL _' || indx
                  ,value_in => rows_in(indx).EMAIL
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'PHONE_NUMBER _' || indx
                  ,value_in => rows_in(indx).PHONE_NUMBER
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'HIRE_DATE _' || indx
                  ,value_in => rows_in(indx).HIRE_DATE
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'JOB_ID _' || indx
                  ,value_in => rows_in(indx).JOB_ID
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'SALARY _' || indx
                  ,value_in => rows_in(indx).SALARY
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'COMMISSION_PCT _' || indx
                  ,value_in => rows_in(indx).COMMISSION_PCT
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'MANAGER_ID _' || indx
                  ,value_in => rows_in(indx).MANAGER_ID
                  ,validate_in => FALSE
                );

                q$error_manager.add_context (
                   err_instance_id_in => l_err_instance_id
                  ,NAME_IN => 'DEPARTMENT_ID _' || indx
                  ,value_in => rows_in(indx).DEPARTMENT_ID
                  ,validate_in => FALSE
                );

                q$error_manager.raise_error_instance( err_instance_id_in => l_err_instance_id );
             END LOOP;
          END bulk_handler;
        END IF;
     WHEN OTHERS
     THEN
       IF NOT handle_error_in THEN RAISE;
       ELSE
       q$error_manager.raise_error(
          error_name_in => 'FORALL-INSERT-FAILURE'
          ,name1_in => 'TABLE_NAME'
          ,value1_in => 'EMPLOYEES'
          ,name2_in => 'ROW_COUNT'
          ,value2_in => rows_in.COUNT
           );
       END IF;
   END ins;
   PROCEDURE upd (
      employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t,
      first_name_in IN EMPLOYEES_TP.FIRST_NAME_t DEFAULT NULL,
      last_name_in IN EMPLOYEES_TP.LAST_NAME_t DEFAULT NULL,
      email_in IN EMPLOYEES_TP.EMAIL_t DEFAULT NULL,
      phone_number_in IN EMPLOYEES_TP.PHONE_NUMBER_t DEFAULT NULL,
      hire_date_in IN EMPLOYEES_TP.HIRE_DATE_t DEFAULT NULL,
      job_id_in IN EMPLOYEES_TP.JOB_ID_t DEFAULT NULL,
      salary_in IN EMPLOYEES_TP.SALARY_t DEFAULT NULL,
      commission_pct_in IN EMPLOYEES_TP.COMMISSION_PCT_t DEFAULT NULL,
      manager_id_in IN EMPLOYEES_TP.MANAGER_ID_t DEFAULT NULL,
      department_id_in IN EMPLOYEES_TP.DEPARTMENT_ID_t DEFAULT NULL,
      ignore_if_null_in IN BOOLEAN := FALSE
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF NVL (ignore_if_null_in, FALSE)
      THEN
         -- Set any columns to their current values
         -- if incoming value is NULL.
         -- Put WHEN clause on column-level triggers!
         UPDATE EMPLOYEES SET
            FIRST_NAME = NVL (first_name_in, FIRST_NAME),
            LAST_NAME = NVL (last_name_in, LAST_NAME),
            EMAIL = NVL (email_in, EMAIL),
            PHONE_NUMBER = NVL (phone_number_in, PHONE_NUMBER),
            HIRE_DATE = NVL (hire_date_in, HIRE_DATE),
            JOB_ID = NVL (job_id_in, JOB_ID),
            SALARY = NVL (salary_in, SALARY),
            COMMISSION_PCT = NVL (commission_pct_in, COMMISSION_PCT),
            MANAGER_ID = NVL (manager_id_in, MANAGER_ID),
            DEPARTMENT_ID = NVL (department_id_in, DEPARTMENT_ID)
          WHERE
             EMPLOYEE_ID = employee_id_in
         ;
      ELSE
         UPDATE EMPLOYEES SET
            FIRST_NAME = first_name_in,
            LAST_NAME = last_name_in,
            EMAIL = email_in,
            PHONE_NUMBER = phone_number_in,
            HIRE_DATE = hire_date_in,
            JOB_ID = job_id_in,
            SALARY = salary_in,
            COMMISSION_PCT = commission_pct_in,
            MANAGER_ID = manager_id_in,
            DEPARTMENT_ID = department_id_in
          WHERE
             EMPLOYEE_ID = employee_id_in
         ;
      END IF;
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id PLS_INTEGER;
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF FALSE THEN NULL; -- Placeholder in case no unique indexes
           ELSIF l_name = 'EMP_EMAIL_UK'
           THEN
              q$error_manager.register_error (
                 error_name_in => 'DUPLICATE-VALUE'
                ,err_instance_id_out => l_err_instance_id
                ,text_in => 'Violation of unique index "EMP_EMAIL_UK"'
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'OWNER'
                ,value_in => l_owner
                ,validate_in => FALSE
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'CONSTRAINT_NAME'
                ,value_in => l_name
                ,validate_in => FALSE
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'TABLE_NAME'
                ,value_in => 'EMPLOYEES'
                ,validate_in => FALSE
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'EMAIL'
                ,value_in => email_in
                ,validate_in => FALSE
                );
              q$error_manager.raise_error_instance (
                    err_instance_id_in => l_err_instance_id);
           ELSE
              q$error_manager.raise_error (
                    error_name_in => 'DUPLICATE-VALUE'
                    ,name1_in => 'OWNER'
                    ,value1_in => l_owner
                    ,name2_in => 'CONSTRAINT_NAME'
                    ,value2_in => l_name
                    ,name3_in => 'TABLE_NAME'
                    ,value3_in => 'EMPLOYEES');
           END IF;
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           IF l_name = 'EMP_DEPT_FK'
           THEN
              -- Add a context value for each column
              q$error_manager.add_context (
                 err_instance_id_in => l_id
               , name_in => 'DEPARTMENT_ID'
               , value_in => department_id_in);
           END IF;
           IF l_name = 'EMP_JOB_FK'
           THEN
              -- Add a context value for each column
              q$error_manager.add_context (
                 err_instance_id_in => l_id
               , name_in => 'JOB_ID'
               , value_in => job_id_in);
           END IF;
           IF l_name = 'EMP_MANAGER_FK'
           THEN
              -- Add a context value for each column
              q$error_manager.add_context (
                 err_instance_id_in => l_id
               , name_in => 'MANAGER_ID'
               , value_in => manager_id_in);
           END IF;
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           q$error_manager.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
   END upd;

   PROCEDURE upd (
      rec_in IN EMPLOYEES_TP.EMPLOYEES_rt,
      ignore_if_null_in IN BOOLEAN := FALSE
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      upd (
         employee_id_in => rec_in.EMPLOYEE_ID,
         first_name_in => rec_in.FIRST_NAME,
         last_name_in => rec_in.LAST_NAME,
         email_in => rec_in.EMAIL,
         phone_number_in => rec_in.PHONE_NUMBER,
         hire_date_in => rec_in.HIRE_DATE,
         job_id_in => rec_in.JOB_ID,
         salary_in => rec_in.SALARY,
         commission_pct_in => rec_in.COMMISSION_PCT,
         manager_id_in => rec_in.MANAGER_ID,
         department_id_in => rec_in.DEPARTMENT_ID

        ,ignore_if_null_in => ignore_if_null_in
        ,handle_error_in => handle_error_in
       );
   END upd;

   PROCEDURE upd_ins (
      employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t,
      first_name_in IN EMPLOYEES_TP.FIRST_NAME_t DEFAULT NULL,
      last_name_in IN EMPLOYEES_TP.LAST_NAME_t DEFAULT NULL,
      email_in IN EMPLOYEES_TP.EMAIL_t DEFAULT NULL,
      phone_number_in IN EMPLOYEES_TP.PHONE_NUMBER_t DEFAULT NULL,
      hire_date_in IN EMPLOYEES_TP.HIRE_DATE_t DEFAULT NULL,
      job_id_in IN EMPLOYEES_TP.JOB_ID_t DEFAULT NULL,
      salary_in IN EMPLOYEES_TP.SALARY_t DEFAULT NULL,
      commission_pct_in IN EMPLOYEES_TP.COMMISSION_PCT_t DEFAULT NULL,
      manager_id_in IN EMPLOYEES_TP.MANAGER_ID_t DEFAULT NULL,
      department_id_in IN EMPLOYEES_TP.DEPARTMENT_ID_t DEFAULT NULL,
      ignore_if_null_in IN BOOLEAN := FALSE
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      upd (
         employee_id_in => employee_id_in,
         first_name_in => first_name_in,
         last_name_in => last_name_in,
         email_in => email_in,
         phone_number_in => phone_number_in,
         hire_date_in => hire_date_in,
         job_id_in => job_id_in,
         salary_in => salary_in,
         commission_pct_in => commission_pct_in,
         manager_id_in => manager_id_in,
         department_id_in => department_id_in
         ,ignore_if_null_in => ignore_if_null_in
         ,handle_error_in => handle_error_in
       );
      IF SQL%ROWCOUNT = 0
      THEN
         ins (
            employee_id_in => employee_id_in,
            first_name_in => first_name_in,
            last_name_in => last_name_in,
            email_in => email_in,
            phone_number_in => phone_number_in,
            hire_date_in => hire_date_in,
            job_id_in => job_id_in,
            salary_in => salary_in,
            commission_pct_in => commission_pct_in,
            manager_id_in => manager_id_in,
            department_id_in => department_id_in
            ,handle_error_in => handle_error_in
         );
      END IF;
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id PLS_INTEGER;
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF FALSE THEN NULL; -- Placeholder in case no unique indexes
           ELSIF l_name = 'EMP_EMAIL_UK'
           THEN
              q$error_manager.register_error (
                 error_name_in => 'DUPLICATE-VALUE'
                ,err_instance_id_out => l_err_instance_id
                ,text_in => 'Violation of unique index "EMP_EMAIL_UK"'
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'OWNER'
                ,value_in => l_owner
                ,validate_in => FALSE
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'CONSTRAINT_NAME'
                ,value_in => l_name
                ,validate_in => FALSE
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'TABLE_NAME'
                ,value_in => 'EMPLOYEES'
                ,validate_in => FALSE
                );
              q$error_manager.add_context (
                 err_instance_id_in => l_err_instance_id
                ,NAME_IN => 'EMAIL'
                ,value_in => email_in
                ,validate_in => FALSE
                );
              q$error_manager.raise_error_instance (
                    err_instance_id_in => l_err_instance_id);
           ELSE
              q$error_manager.raise_error (
                    error_name_in => 'DUPLICATE-VALUE'
                    ,name1_in => 'OWNER'
                    ,value1_in => l_owner
                    ,name2_in => 'CONSTRAINT_NAME'
                    ,value2_in => l_name
                    ,name3_in => 'TABLE_NAME'
                    ,value3_in => 'EMPLOYEES');
           END IF;
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           IF l_name = 'EMP_DEPT_FK'
           THEN
              -- Add a context value for each column
              q$error_manager.add_context (
                 err_instance_id_in => l_id
               , name_in => 'DEPARTMENT_ID'
               , value_in => department_id_in);
           END IF;
           IF l_name = 'EMP_JOB_FK'
           THEN
              -- Add a context value for each column
              q$error_manager.add_context (
                 err_instance_id_in => l_id
               , name_in => 'JOB_ID'
               , value_in => job_id_in);
           END IF;
           IF l_name = 'EMP_MANAGER_FK'
           THEN
              -- Add a context value for each column
              q$error_manager.add_context (
                 err_instance_id_in => l_id
               , name_in => 'MANAGER_ID'
               , value_in => manager_id_in);
           END IF;
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           q$error_manager.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
   END upd_ins;


   PROCEDURE upd (
      col_in IN EMPLOYEES_TP.EMPLOYEES_tc,
      ignore_if_null_in IN BOOLEAN := FALSE
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
      l_EMPLOYEE_ID EMPLOYEES_TP.EMPLOYEE_ID_cc;
      l_FIRST_NAME EMPLOYEES_TP.FIRST_NAME_cc;
      l_LAST_NAME EMPLOYEES_TP.LAST_NAME_cc;
      l_EMAIL EMPLOYEES_TP.EMAIL_cc;
      l_PHONE_NUMBER EMPLOYEES_TP.PHONE_NUMBER_cc;
      l_HIRE_DATE EMPLOYEES_TP.HIRE_DATE_cc;
      l_JOB_ID EMPLOYEES_TP.JOB_ID_cc;
      l_SALARY EMPLOYEES_TP.SALARY_cc;
      l_COMMISSION_PCT EMPLOYEES_TP.COMMISSION_PCT_cc;
      l_MANAGER_ID EMPLOYEES_TP.MANAGER_ID_cc;
      l_DEPARTMENT_ID EMPLOYEES_TP.DEPARTMENT_ID_cc;
   BEGIN
      FOR i IN col_in.FIRST .. col_in.LAST loop
         l_EMPLOYEE_ID(i) := col_in(i).EMPLOYEE_ID;
         l_FIRST_NAME(i) := col_in(i).FIRST_NAME;
         l_LAST_NAME(i) := col_in(i).LAST_NAME;
         l_EMAIL(i) := col_in(i).EMAIL;
         l_PHONE_NUMBER(i) := col_in(i).PHONE_NUMBER;
         l_HIRE_DATE(i) := col_in(i).HIRE_DATE;
         l_JOB_ID(i) := col_in(i).JOB_ID;
         l_SALARY(i) := col_in(i).SALARY;
         l_COMMISSION_PCT(i) := col_in(i).COMMISSION_PCT;
         l_MANAGER_ID(i) := col_in(i).MANAGER_ID;
         l_DEPARTMENT_ID(i) := col_in(i).DEPARTMENT_ID;
      END LOOP;
      IF NVL (ignore_if_null_in, FALSE)
      THEN
         -- Set any columns to their current values
         -- if incoming value is NULL.
         -- Put WHEN clause on column-level triggers!
         FORALL i IN col_in.FIRST .. col_in.LAST
            UPDATE EMPLOYEES SET
               FIRST_NAME = NVL (l_FIRST_NAME(i), FIRST_NAME),
               LAST_NAME = NVL (l_LAST_NAME(i), LAST_NAME),
               EMAIL = NVL (l_EMAIL(i), EMAIL),
               PHONE_NUMBER = NVL (l_PHONE_NUMBER(i), PHONE_NUMBER),
               HIRE_DATE = NVL (l_HIRE_DATE(i), HIRE_DATE),
               JOB_ID = NVL (l_JOB_ID(i), JOB_ID),
               SALARY = NVL (l_SALARY(i), SALARY),
               COMMISSION_PCT = NVL (l_COMMISSION_PCT(i), COMMISSION_PCT),
               MANAGER_ID = NVL (l_MANAGER_ID(i), MANAGER_ID),
               DEPARTMENT_ID = NVL (l_DEPARTMENT_ID(i), DEPARTMENT_ID)
             WHERE
                EMPLOYEE_ID = l_EMPLOYEE_ID(i)
         ;
      ELSE
         FORALL i IN col_in.FIRST .. col_in.LAST
            UPDATE EMPLOYEES SET
               FIRST_NAME = l_FIRST_NAME(i),
               LAST_NAME = l_LAST_NAME(i),
               EMAIL = l_EMAIL(i),
               PHONE_NUMBER = l_PHONE_NUMBER(i),
               HIRE_DATE = l_HIRE_DATE(i),
               JOB_ID = l_JOB_ID(i),
               SALARY = l_SALARY(i),
               COMMISSION_PCT = l_COMMISSION_PCT(i),
               MANAGER_ID = l_MANAGER_ID(i),
               DEPARTMENT_ID = l_DEPARTMENT_ID(i)
             WHERE
                EMPLOYEE_ID = l_EMPLOYEE_ID(i)
         ;
      END IF;
   END upd;
   FUNCTION dynupdstr (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      where_in IN VARCHAR2 := NULL)
   RETURN VARCHAR2
   IS
   BEGIN
      RETURN
         'UPDATE EMPLOYEES
             SET ' || colname_in || ' = :value
           WHERE ' || NVL (where_in, '1=1');
   END dynupdstr;
   PROCEDURE upd_onecol (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN VARCHAR2,
      where_in IN VARCHAR2 := NULL
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dynupdstr (colname_in, where_in)
      USING new_value_in;
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id PLS_INTEGER;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           q$error_manager.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
   END upd_onecol;

    PROCEDURE upd_onecol (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN DATE,
      where_in IN VARCHAR2 := NULL
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dynupdstr (colname_in, where_in)
      USING new_value_in;
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id PLS_INTEGER;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           q$error_manager.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
   END upd_onecol;

    PROCEDURE upd_onecol (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN NUMBER,
      where_in IN VARCHAR2 := NULL
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dynupdstr (colname_in, where_in)
      USING new_value_in;
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id PLS_INTEGER;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           q$error_manager.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
   END upd_onecol;
   PROCEDURE upd_onecol_pky (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN VARCHAR2
     ,employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_column_name ALL_TAB_COLUMNS.COLUMN_NAME%TYPE := UPPER (colname_in);
   BEGIN
      IF l_column_name = 'FIRST_NAME' THEN
         UPDATE EMPLOYEES
            SET FIRST_NAME = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_column_name = 'LAST_NAME' THEN
         UPDATE EMPLOYEES
            SET LAST_NAME = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_column_name = 'EMAIL' THEN
         UPDATE EMPLOYEES
            SET EMAIL = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_column_name = 'PHONE_NUMBER' THEN
         UPDATE EMPLOYEES
            SET PHONE_NUMBER = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_column_name = 'JOB_ID' THEN
         UPDATE EMPLOYEES
            SET JOB_ID = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      <<update_complete>>
      NULL; -- Ensures there is SOMETHING here....
      NULL; -- Guarantee valid block.
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id PLS_INTEGER;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           q$error_manager.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
   END upd_onecol_pky;
   PROCEDURE upd_onecol_pky (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN DATE
     ,employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_column_name ALL_TAB_COLUMNS.COLUMN_NAME%TYPE := UPPER (colname_in);
   BEGIN
      IF l_column_name = 'HIRE_DATE' THEN
         UPDATE EMPLOYEES
            SET HIRE_DATE = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      <<update_complete>>
      NULL; -- Ensures there is SOMETHING here....
      NULL; -- Guarantee valid block.
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id PLS_INTEGER;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           q$error_manager.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
   END upd_onecol_pky;
   PROCEDURE upd_onecol_pky (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
      new_value_in IN NUMBER
     ,employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
      l_column_name ALL_TAB_COLUMNS.COLUMN_NAME%TYPE := UPPER (colname_in);
   BEGIN
      IF l_column_name = 'EMPLOYEE_ID' THEN
         UPDATE EMPLOYEES
            SET EMPLOYEE_ID = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_column_name = 'SALARY' THEN
         UPDATE EMPLOYEES
            SET SALARY = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_column_name = 'COMMISSION_PCT' THEN
         UPDATE EMPLOYEES
            SET COMMISSION_PCT = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_column_name = 'MANAGER_ID' THEN
         UPDATE EMPLOYEES
            SET MANAGER_ID = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      IF l_column_name = 'DEPARTMENT_ID' THEN
         UPDATE EMPLOYEES
            SET DEPARTMENT_ID = new_value_in
          WHERE
             EMPLOYEE_ID = employee_id_in
              ;
         -- Perfect time for a GOTO!
         GOTO update_complete;
      END IF;
      <<update_complete>>
      NULL; -- Ensures there is SOMETHING here....
      NULL; -- Guarantee valid block.
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_err_instance_id PLS_INTEGER;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'DUPLICATE-VALUE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
      WHEN e_null_column_value
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           v_errm VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
           dot1loc INTEGER;
           dot2loc INTEGER;
           parenloc INTEGER;
           c_owner ALL_CONSTRAINTS.OWNER%TYPE;
           c_tabname ALL_TABLES.TABLE_NAME%TYPE;
           c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
           dot1loc := INSTR (v_errm, '.', 1, 1);
           dot2loc := INSTR (v_errm, '.', 1, 2);
           parenloc := INSTR (v_errm, '(');
           c_owner :=SUBSTR (v_errm, parenloc+1, dot1loc-parenloc-1);
           c_tabname := SUBSTR (v_errm, dot1loc+1, dot2loc-dot1loc-1);
           c_colname := SUBSTR (v_errm, dot2loc+1, INSTR (v_errm,')')-dot2loc-1);

           q$error_manager.raise_error (
                error_name_in => 'COLUMN-CANNOT-BE-NULL'
               ,name1_in => 'OWNER'
               ,value1_in => c_owner
               ,name2_in => 'TABLE_NAME'
               ,value2_in => c_tabname
               ,name3_in => 'COLUMN_NAME'
               ,value3_in => c_colname);
        END;
        END IF;
   END upd_onecol_pky;

    -- Set all non-primary key columns to NULL
   PROCEDURE nullify_row (
      employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t
      ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      upd (
         employee_id_in => employee_id_in,
         phone_number_in => NULL,
         salary_in => NULL,
         commission_pct_in => NULL,
         manager_id_in => NULL,
         department_id_in => NULL,
         ignore_if_null_in => FALSE
         ,handle_error_in => handle_error_in
       );
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END nullify_row;

   -- Delete functionality
   PROCEDURE del (
      employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      DELETE FROM EMPLOYEES
       WHERE
          EMPLOYEE_ID = employee_id_in
         ;
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END del;

   -- Delete all rows for primary key column EMPLOYEE_ID
   PROCEDURE del_EMPLOYEE_ID (
      employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t
     ,handle_error_in IN BOOLEAN := TRUE
     )
   IS
   BEGIN
      DELETE FROM EMPLOYEES
       WHERE EMPLOYEE_ID = employee_id_in;
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END del_EMPLOYEE_ID;
   -- Delete for unique value of EMP_EMAIL_UK
   PROCEDURE del_EMP_EMAIL_UK (
      email_in IN EMPLOYEES_TP.EMAIL_t
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      DELETE FROM EMPLOYEES
       WHERE
          EMAIL = email_in
         ;
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END del_EMP_EMAIL_UK;

   PROCEDURE del_EMP_DEPT_FK (
      department_id_in IN EMPLOYEES_TP.DEPARTMENT_ID_t
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      DELETE FROM EMPLOYEES
       WHERE
          DEPARTMENT_ID = del_EMP_DEPT_FK.department_id_in
         ;
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END del_EMP_DEPT_FK;

   PROCEDURE del_EMP_JOB_FK (
      job_id_in IN EMPLOYEES_TP.JOB_ID_t
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      DELETE FROM EMPLOYEES
       WHERE
          JOB_ID = del_EMP_JOB_FK.job_id_in
         ;
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END del_EMP_JOB_FK;

   PROCEDURE del_EMP_MANAGER_FK (
      manager_id_in IN EMPLOYEES_TP.MANAGER_ID_t
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      DELETE FROM EMPLOYEES
       WHERE
          MANAGER_ID = del_EMP_MANAGER_FK.manager_id_in
         ;
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END del_EMP_MANAGER_FK;

   -- Deletions using dynamic SQL
   FUNCTION dyndelstr (where_in IN VARCHAR2) RETURN VARCHAR2
   IS
   BEGIN
      IF where_in IS NULL
      THEN
         RETURN 'DELETE FROM EMPLOYEES';
      ELSE
         RETURN
            'DELETE FROM EMPLOYEES WHERE ' || where_in;
      END IF;
   END dyndelstr;

   FUNCTION dyncoldelstr (
      colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN dyndelstr ( colname_in || ' = :value' );
   END;

   PROCEDURE del_by (
      where_clause_in IN VARCHAR2
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      EXECUTE IMMEDIATE dyndelstr (where_clause_in);
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END del_by;

   PROCEDURE del_by_col (
      colname_in IN VARCHAR2,
      colvalue_in IN VARCHAR2
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dyncoldelstr (colname_in)
         USING colvalue_in;
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END del_by_col;

   PROCEDURE del_by_col (
      colname_in IN VARCHAR2,
      colvalue_in IN DATE
     ,handle_error_in IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      EXECUTE IMMEDIATE dyncoldelstr (colname_in)
         USING colvalue_in;
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END del_by_col;

   PROCEDURE del_by_col (
      colname_in IN VARCHAR2,
      colvalue_in IN NUMBER
     ,handle_error_in IN BOOLEAN := TRUE
   )
   IS
   BEGIN
      EXECUTE IMMEDIATE dyncoldelstr (colname_in)
         USING colvalue_in;
   EXCEPTION
      WHEN e_check_constraint_failure
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
           get_constraint_info (l_owner, l_name);
           q$error_manager.raise_error (
              error_name_in => 'CHECK-CONSTRAINT-FAILURE'
             ,name1_in => 'OWNER'
             ,value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME'
             ,value2_in => l_name
             ,name3_in => 'TABLE_NAME'
             ,value3_in => 'EMPLOYEES');
        END;
        END IF;
      WHEN e_integ_constraint_failure OR e_no_parent_key OR e_child_record_found
      THEN
        IF NOT handle_error_in THEN RAISE;
        ELSE
        DECLARE
           l_owner ALL_CONSTRAINTS.OWNER%TYPE;
           l_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
           l_id PLS_INTEGER;
           l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
           get_constraint_info (l_owner, l_name);
           IF SQLCODE = -2292 -- Child record found
           THEN
              l_err_name := 'CHILD-RECORD-FOUND' ;
           END IF;
           q$error_manager.register_error (
              error_name_in => l_err_name
             ,err_instance_id_out => l_id
             ,name1_in => 'OWNER', value1_in => l_owner
             ,name2_in => 'CONSTRAINT_NAME', value2_in => l_name
             ,name3_in => 'TABLE_NAME', value3_in => 'EMPLOYEES');
           q$error_manager.raise_error_instance (err_instance_id_in => l_id);
        END;
        END IF;
   END del_by_col;

   -- Initialize a record with default values for columns in the table.
   PROCEDURE initrec (
      employees_inout IN OUT EMPLOYEES_TP.EMPLOYEES_rt
   )
   IS
   BEGIN
      employees_inout.EMPLOYEE_ID := NULL;
      employees_inout.FIRST_NAME := NULL;
      employees_inout.LAST_NAME := NULL;
      employees_inout.EMAIL := NULL;
      employees_inout.PHONE_NUMBER := NULL;
      employees_inout.HIRE_DATE := NULL;
      employees_inout.JOB_ID := NULL;
      employees_inout.SALARY := NULL;
      employees_inout.COMMISSION_PCT := NULL;
      employees_inout.MANAGER_ID := NULL;
      employees_inout.DEPARTMENT_ID := NULL;
   END initrec;

   FUNCTION initrec RETURN EMPLOYEES_TP.EMPLOYEES_rt
   IS
      l_employees EMPLOYEES_TP.EMPLOYEES_rt;
   BEGIN
      RETURN l_employees;
   END initrec;

BEGIN
   NULL;
END EMPLOYEES_CP;
/
