CREATE OR REPLACE PACKAGE BODY EMPLOYEES_UP
/*
| Generated by or retrieved from QCGU - DO NOT MODIFY!
| QCGU - "Get it right, do it fast" - www.ToadWorld.com
| QCGU Universal ID: {5A47CF03-58E8-4963-9210-3278890D2424}
| Created On: October 14, 2011 6:44:29
| Created By: QCGU
*/
IS
   -- Used in snapshots
   c_squote CONSTANT VARCHAR2(4) := '''';
   c_dquote CONSTANT VARCHAR2(6) := '''''';
   c_procname ALL_OBJECTS.OBJECT_NAME%TYPE := 'qnxo$snapshot$ins';
   -- Functions to convert variables into strings for snapshots
   FUNCTION replace_string (
      val_in IN VARCHAR2
     ,add_comma_in IN BOOLEAN := TRUE
   )
      RETURN VARCHAR2
   IS
      retval   VARCHAR2 (32767);
   BEGIN
      IF val_in IS NULL
      THEN
         retval := 'NULL';
      ELSIF INSTR (val_in, c_squote) > 0
      THEN
         retval := '''' || REPLACE (val_in, c_squote, c_dquote) || '''';
      ELSE
         retval := '''' || val_in || '''';
      END IF;
       IF add_comma_in
      THEN
         retval := retval || ',';
      END IF;
       RETURN retval;
   END;

   FUNCTION replace_string (val_in IN DATE,
       add_comma_in IN BOOLEAN := TRUE) RETURN VARCHAR2
    IS
       retval VARCHAR2(32767);
    BEGIN
       IF val_in IS NULL THEN retval := 'NULL';
       ELSE
          retval := 'TO_DATE('
           || STANDARD.TO_CHAR (val_in, 'YYYYMMDDHH24MISS')
           || ', ''YYYYMMDDHH24MISS'')';
       END IF;
       IF add_comma_in THEN retval := retval || ','; END IF;
       RETURN retval;
    END;

     FUNCTION replace_string (val_in IN NUMBER,
       add_comma_in IN BOOLEAN := TRUE) RETURN VARCHAR2
    IS
       retval VARCHAR2(32767);
    BEGIN
       IF val_in IS NULL THEN retval := 'NULL';
       ELSE retval := 'TO_CHAR(' || val_in || ')';
       END IF;
       IF add_comma_in THEN retval := retval || ','; END IF;
       RETURN retval;
    END;

   /* BLOB support is disabled until we can allow the users
      to specify whether they want this code to be used for
      Oracle8i (will not work) or above.
   FUNCTION replace_string (val_in IN BLOB, add_comma_in IN BOOLEAN := TRUE)
      RETURN VARCHAR2
   IS
      retval   VARCHAR2 (32767);
   BEGIN
      IF val_in IS NULL
      THEN
         retval := 'NULL';
      ELSE
         retval := 'TO_CHAR(' || UTL_RAW.cast_to_varchar2 (val_in) || ')';
      END IF;

      IF add_comma_in
      THEN
         retval := retval || ',';
      END IF;

      RETURN retval;
   END;
   */

   -- Display functionality
   FUNCTION to_char (
        rec_in IN EMPLOYEES_TP.EMPLOYEES_rt
      , delimiter_in IN VARCHAR2 := CHR(10) -- Carriage return
      )
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN LTRIM (NULL
         || delimiter_in || 'FIRST_NAME = ' || rec_in.FIRST_NAME
         || delimiter_in || 'LAST_NAME = ' || rec_in.LAST_NAME
         || delimiter_in || 'EMAIL = ' || rec_in.EMAIL
         || delimiter_in || 'PHONE_NUMBER = ' || rec_in.PHONE_NUMBER
         || delimiter_in || 'HIRE_DATE = ' || STANDARD.TO_CHAR (rec_in.HIRE_DATE)
         || delimiter_in || 'JOB_ID = ' || rec_in.JOB_ID
         || delimiter_in || 'SALARY = ' || STANDARD.TO_CHAR (rec_in.SALARY)
         || delimiter_in || 'COMMISSION_PCT = ' || STANDARD.TO_CHAR (rec_in.COMMISSION_PCT)
         || delimiter_in || 'MANAGER_ID = ' || STANDARD.TO_CHAR (rec_in.MANAGER_ID)
         || delimiter_in || 'DEPARTMENT_ID = ' || STANDARD.TO_CHAR (rec_in.DEPARTMENT_ID)
      , delimiter_in);
   END to_char;

    FUNCTION to_char (
      employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t,
      delimiter_in IN VARCHAR2 := CHR(10) -- Carriage return
      )
      RETURN VARCHAR2
   IS
      l_rec EMPLOYEES_TP.EMPLOYEES_rt;
   BEGIN
      l_rec := EMPLOYEES_QP.onerow (
            employee_id_in
            );
      RETURN EMPLOYEES_UP.to_char (l_rec, delimiter_in);
   END to_char;

    PROCEDURE display_row (
      employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t,
      delimiter_in IN VARCHAR2 := CHR(10) -- Carriage return
      )
   IS
   BEGIN
      q$error_manager.pl (
         EMPLOYEES_UP.to_char (
            employee_id_in,
            delimiter_in
            )
         );
   END display_row;

    PROCEDURE display_row (
        rec_in IN EMPLOYEES_TP.EMPLOYEES_rt
      , delimiter_in IN VARCHAR2 := CHR(10) -- Carriage return
      )
   IS
   BEGIN
      q$error_manager.pl (
          EMPLOYEES_UP.to_char (rec_in, delimiter_in));
   END display_row;

    PROCEDURE dump_to_file (
      loc_in IN VARCHAR2
    , file_in IN VARCHAR2
    , where_in IN VARCHAR2 := NULL
    , delimiter_in IN VARCHAR2 := '|'
    )
   IS
      fid UTL_FILE.FILE_TYPE;
      l_index PLS_INTEGER;
      line VARCHAR2(32767);
      l_EMPLOYEES EMPLOYEES_TP.EMPLOYEES_tc;
   BEGIN
      fid := UTL_FILE.FOPEN (loc_in, file_in, 'W', max_linesize => 32767);
      l_EMPLOYEES := EMPLOYEES_QP.allrows_by (NVL (where_in, '1=1'));
      l_index := l_EMPLOYEES.FIRST;
      WHILE (l_index IS NOT NULL)
      LOOP
         UTL_FILE.PUT_LINE (fid,
           to_char (l_EMPLOYEES(l_index), delimiter_in));
         l_index := l_EMPLOYEES.NEXT (l_index);
      END LOOP;
      UTL_FILE.FCLOSE (fid);
   END dump_to_file;
    PROCEDURE copy (
      -- Primary key to identify source row
      employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t,
      -- New value parameters, overriding existing ones.
      FIRST_NAME_nv IN EMPLOYEES_TP.FIRST_NAME_t DEFAULT NULL,
      LAST_NAME_nv IN EMPLOYEES_TP.LAST_NAME_t DEFAULT NULL,
      EMAIL_nv IN EMPLOYEES_TP.EMAIL_t DEFAULT NULL,
      PHONE_NUMBER_nv IN EMPLOYEES_TP.PHONE_NUMBER_t DEFAULT NULL,
      HIRE_DATE_nv IN EMPLOYEES_TP.HIRE_DATE_t DEFAULT NULL,
      JOB_ID_nv IN EMPLOYEES_TP.JOB_ID_t DEFAULT NULL,
      SALARY_nv IN EMPLOYEES_TP.SALARY_t DEFAULT NULL,
      COMMISSION_PCT_nv IN EMPLOYEES_TP.COMMISSION_PCT_t DEFAULT NULL,
      MANAGER_ID_nv IN EMPLOYEES_TP.MANAGER_ID_t DEFAULT NULL,
      DEPARTMENT_ID_nv IN EMPLOYEES_TP.DEPARTMENT_ID_t DEFAULT NULL,
      -- Generated primary key value
      employee_id_out IN OUT EMPLOYEES_TP.EMPLOYEE_ID_t,
      prefix_in IN VARCHAR2 DEFAULT NULL,
      suffix_in IN VARCHAR2 DEFAULT NULL
      )
   IS
      l_EMPLOYEES EMPLOYEES_TP.EMPLOYEES_rt;
      l_prefix ALL_OBJECTS.OBJECT_NAME%TYPE;
      l_suffix ALL_OBJECTS.OBJECT_NAME%TYPE;
   BEGIN
      l_EMPLOYEES := EMPLOYEES_QP.onerow (
         employee_id_in
         );
      l_EMPLOYEES.FIRST_NAME := NVL (FIRST_NAME_nv, l_EMPLOYEES.FIRST_NAME);
      l_EMPLOYEES.LAST_NAME := NVL (LAST_NAME_nv, l_EMPLOYEES.LAST_NAME);
      l_EMPLOYEES.EMAIL := NVL (EMAIL_nv, l_EMPLOYEES.EMAIL);
      l_EMPLOYEES.PHONE_NUMBER := NVL (PHONE_NUMBER_nv, l_EMPLOYEES.PHONE_NUMBER);
      l_EMPLOYEES.HIRE_DATE := NVL (HIRE_DATE_nv, l_EMPLOYEES.HIRE_DATE);
      l_EMPLOYEES.JOB_ID := NVL (JOB_ID_nv, l_EMPLOYEES.JOB_ID);
      l_EMPLOYEES.SALARY := NVL (SALARY_nv, l_EMPLOYEES.SALARY);
      l_EMPLOYEES.COMMISSION_PCT := NVL (COMMISSION_PCT_nv, l_EMPLOYEES.COMMISSION_PCT);
      l_EMPLOYEES.MANAGER_ID := NVL (MANAGER_ID_nv, l_EMPLOYEES.MANAGER_ID);
      l_EMPLOYEES.DEPARTMENT_ID := NVL (DEPARTMENT_ID_nv, l_EMPLOYEES.DEPARTMENT_ID);
       EMPLOYEES_CP.ins (
         first_name_in => l_EMPLOYEES.FIRST_NAME,
         last_name_in => l_EMPLOYEES.LAST_NAME,
         email_in => l_EMPLOYEES.EMAIL,
         phone_number_in => l_EMPLOYEES.PHONE_NUMBER,
         hire_date_in => l_EMPLOYEES.HIRE_DATE,
         job_id_in => l_EMPLOYEES.JOB_ID,
         salary_in => l_EMPLOYEES.SALARY,
         commission_pct_in => l_EMPLOYEES.COMMISSION_PCT,
         manager_id_in => l_EMPLOYEES.MANAGER_ID,
         department_id_in => l_EMPLOYEES.DEPARTMENT_ID,
         employee_id_out => employee_id_out
         );
       -- Call the XP stub to do any additional, customized
      -- copy processing. Pass in the from ID info and the
      -- to ID info.
      BEGIN
        EXECUTE IMMEDIATE 'BEGIN EMPLOYEES_XP.copy (
                f_EMPLOYEE_ID => :FEMPLOYEE_ID,
                t_EMPLOYEE_ID => :TEMPLOYEE_ID,
                prefix_in => :prefix, suffix_in => :suffix); END;'
           USING
                employee_id_in,
                employee_id_out,
                l_prefix, l_suffix;
      EXCEPTION
         WHEN DUP_VAL_ON_INDEX
         THEN
             RAISE;
         WHEN OTHERS THEN NULL;
      END;
   END copy;

   -- Simpler, cleaner code, useful for cutting and pasting into
   -- custom snapshot programs. Assumes you are passing in the primary key.
   -- Especially good fit when working with GUIDs for PKYs.
   PROCEDURE simplified_make_snapshot (
      sf_snapshot_grp_id_in IN sf_snapshot_grp_tp.id_t
    , employee_id_in IN EMPLOYEES_TP.EMPLOYEE_ID_t
   )
  IS
     c_varname VARCHAR2(30) := 'l_EMPLOYEES';
     l_EMPLOYEES EMPLOYEES_TP.EMPLOYEES_rt;
     l_sf_snapshot_id sf_snapshot_tp.id_t;

     FUNCTION replace_string (
        val_in IN VARCHAR2
       ,add_comma_in IN BOOLEAN := TRUE
     )
        RETURN VARCHAR2
     IS
        retval   VARCHAR2 (32767);
     BEGIN
        IF val_in IS NULL
        THEN
           retval := 'NULL';
        ELSIF INSTR (val_in, c_squote) > 0
        THEN
           retval := '''' || REPLACE (val_in, c_squote, c_dquote) || '''';
        ELSE
           retval := '''' || val_in || '''';
        END IF;
         IF add_comma_in
        THEN
           retval := retval || ',';
        END IF;
         RETURN retval;
     END;

     FUNCTION replace_string (val_in IN DATE,
         add_comma_in IN BOOLEAN := TRUE) RETURN VARCHAR2
      IS
         retval VARCHAR2(32767);
      BEGIN
         IF val_in IS NULL THEN retval := 'NULL';
         ELSE
            retval := 'TO_DATE('
             || STANDARD.TO_CHAR (val_in, 'YYYYMMDDHH24MISS')
             || ', ''YYYYMMDDHH24MISS'')';
         END IF;
         IF add_comma_in THEN retval := retval || ','; END IF;
         RETURN retval;
      END;

     FUNCTION replace_string (val_in IN NUMBER,
         add_comma_in IN BOOLEAN := TRUE) RETURN VARCHAR2
     IS
         retval VARCHAR2(32767);
     BEGIN
         IF val_in IS NULL THEN retval := 'NULL';
         ELSE retval := 'TO_CHAR(' || val_in || ')';
         END IF;
         IF add_comma_in THEN retval := retval || ','; END IF;
         RETURN retval;
     END;

     PROCEDURE pl (str IN VARCHAR2)
     IS
     BEGIN
        sf_snapshot_grp_xp.pl_snapshot (l_sf_snapshot_id, str);
     END pl;
  BEGIN
     l_EMPLOYEES := EMPLOYEES_QP.onerow (
        employee_id_in
        );
     sf_snapshot_grp_xp.pl_snapshot_header (
        sf_snapshot_grp_id_in
      , l_sf_snapshot_id
      , proc_name_in => c_procname
      );
     pl ('EMPLOYEES_CP.ins (');
     pl ('employee_id_in => ' || replace_string (l_EMPLOYEES.EMPLOYEE_ID));
     pl ('first_name_in => ' || replace_string (l_EMPLOYEES.FIRST_NAME));
     pl ('last_name_in => ' || replace_string (l_EMPLOYEES.LAST_NAME));
     pl ('email_in => ' || replace_string (l_EMPLOYEES.EMAIL));
     pl ('phone_number_in => ' || replace_string (l_EMPLOYEES.PHONE_NUMBER));
     pl ('hire_date_in => ' || replace_string (l_EMPLOYEES.HIRE_DATE));
     pl ('job_id_in => ' || replace_string (l_EMPLOYEES.JOB_ID));
     pl ('salary_in => ' || replace_string (l_EMPLOYEES.SALARY));
     pl ('commission_pct_in => ' || replace_string (l_EMPLOYEES.COMMISSION_PCT));
     pl ('manager_id_in => ' || replace_string (l_EMPLOYEES.MANAGER_ID));
     pl ('department_id_in => ' || replace_string (l_EMPLOYEES.DEPARTMENT_ID));
     pl ('  handle_error_in => FALSE);');
     pl ('END;');
     sf_snapshot_grp_xp.pl_snapshot_closure (sf_snapshot_grp_id_in, l_sf_snapshot_id, c_procname);
   END simplified_make_snapshot;
END EMPLOYEES_UP;
/
