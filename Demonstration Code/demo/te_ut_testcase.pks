CREATE OR REPLACE PACKAGE te_ut_testcase
--//-----------------------------------------------------------------------
--//  ** PL/Generator Table Encapsulator for "UT_TESTCASE"
--//-----------------------------------------------------------------------
--//  (c) COPYRIGHT  2003.
--//               All rights reserved.
--//
--//  No part of this copyrighted work may be reproduced, modified,
--//  or distributed in any form or by any means without the prior
--//  written permission of .
--//-----------------------------------------------------------------------
--//  This software was generated by Quest Software's PL/Generator (TM).
--//
--//  For more information, visit www.Quest Software.com or call 1.800.REVEAL4
--//-----------------------------------------------------------------------
--//  Stored In:  te_ut_testcase.pks
--//  Created On: May       09, 2003 16:37:37
--//  Created By: SCOTT
--//  PL/Generator Version: PRO-2000.2.8
--//-----------------------------------------------------------------------
IS
--// Data Structures //--
   TYPE pky_rt IS RECORD (
      id UT_TESTCASE.ID%TYPE
      );

   TYPE cv_t IS REF CURSOR;

   TYPE ut_testcase_idx1_rt IS RECORD (
      name UT_TESTCASE.NAME%TYPE
      );

--// Cursors //--

   CURSOR allbypky_cur
   IS
      SELECT
         ID,
         UNITTEST_ID,
         NAME,
         SEQ,
         DESCRIPTION,
         STATUS,
         DECLARATIONS,
         SETUP,
         TEARDOWN,
         EXCEPTIONS,
         TEST_ID,
         PREFIX,
         ASSERTION,
         INLINE_ASSERTION_CALL,
         EXECUTIONS,
         FAILURES,
         LAST_START,
         LAST_END
        FROM UT_TESTCASE
       ORDER BY
         ID
      ;

   CURSOR allforpky_cur (
      id_in IN UT_TESTCASE.ID%TYPE
      )
   IS
      SELECT
         ID,
         UNITTEST_ID,
         NAME,
         SEQ,
         DESCRIPTION,
         STATUS,
         DECLARATIONS,
         SETUP,
         TEARDOWN,
         EXCEPTIONS,
         TEST_ID,
         PREFIX,
         ASSERTION,
         INLINE_ASSERTION_CALL,
         EXECUTIONS,
         FAILURES,
         LAST_START,
         LAST_END
        FROM UT_TESTCASE
       WHERE
         ID = allforpky_cur.id_in
      ;

   --// Specified columns, all rows for this foreign key. //--
   CURSOR ut_testcase_unitest_fk_all_cur (
      unittest_id_in IN UT_TESTCASE.UNITTEST_ID%TYPE
      )
   IS
      SELECT
         ID,
         UNITTEST_ID,
         NAME,
         SEQ,
         DESCRIPTION,
         STATUS,
         DECLARATIONS,
         SETUP,
         TEARDOWN,
         EXCEPTIONS,
         TEST_ID,
         PREFIX,
         ASSERTION,
         INLINE_ASSERTION_CALL,
         EXECUTIONS,
         FAILURES,
         LAST_START,
         LAST_END
        FROM UT_TESTCASE
       WHERE
          UNITTEST_ID = ut_testcase_unitest_fk_all_cur.unittest_id_in
      ;

--// Cursor management procedures //--

   --// Open the cursors with some options. //--
   PROCEDURE open_allforpky_cur (
      id_in IN UT_TESTCASE.ID%TYPE,
      close_if_open IN BOOLEAN := TRUE
      );

   PROCEDURE open_allbypky_cur (
      close_if_open IN BOOLEAN := TRUE
      );

   PROCEDURE open_ut_testcase_unitest_fk_al (
      unittest_id_in IN UT_TESTCASE.UNITTEST_ID%TYPE,
      close_if_open IN BOOLEAN := TRUE
      );

   --// Close the cursors if they are open. //--
   PROCEDURE close_allforpky_cur;
   PROCEDURE close_allbypky_cur;
   PROCEDURE close_ut_testcase_unitest_fk_a;
   PROCEDURE closeall;

--// Analyze presence of primary key: is it NOT NULL? //--

   FUNCTION isnullpky (
      rec_in IN UT_TESTCASE%ROWTYPE
      )
   RETURN BOOLEAN;

   FUNCTION isnullpky (
      rec_in IN pky_rt
      )
   RETURN BOOLEAN;

--// Emulate aggregate-level record operations. //--

   FUNCTION recseq (rec1 IN UT_TESTCASE%ROWTYPE, rec2 IN UT_TESTCASE%ROWTYPE)
   RETURN BOOLEAN;

   FUNCTION recseq (rec1 IN pky_rt, rec2 IN pky_rt)
   RETURN BOOLEAN;

--// Fetch Data //--

   --// Fetch one row of data for a primary key. //--
   FUNCTION onerow (
      id_in IN UT_TESTCASE.ID%TYPE
      )
   RETURN UT_TESTCASE%ROWTYPE;

   --// For each unique index ... //--

   FUNCTION ut_testcase_idx1$pky (
      name_in IN UT_TESTCASE.NAME%TYPE
      )
      RETURN pky_rt
      ;

   FUNCTION ut_testcase_idx1$val (
      id_in IN UT_TESTCASE.ID%TYPE
      )
   RETURN ut_testcase_idx1_rt;

   FUNCTION ut_testcase_idx1$row (
      name_in IN UT_TESTCASE.NAME%TYPE
      )
   RETURN UT_TESTCASE%ROWTYPE;


   --// Count of all rows in table and for each foreign key. //--
   FUNCTION rowcount RETURN INTEGER;
   FUNCTION pkyrowcount (
      id_in IN UT_TESTCASE.ID%TYPE
      )
      RETURN INTEGER;
   FUNCTION ut_testcase_unitest_fkrowcount (
      unittest_id_in IN UT_TESTCASE.UNITTEST_ID%TYPE
      )
      RETURN INTEGER;
--// Update Processing //--

   PROCEDURE reset$frc;

   --// Force setting of NULL values //--

   FUNCTION unittest_id$frc
      (unittest_id_in IN UT_TESTCASE.UNITTEST_ID%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.UNITTEST_ID%TYPE;

   FUNCTION name$frc
      (name_in IN UT_TESTCASE.NAME%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.NAME%TYPE;

   FUNCTION seq$frc
      (seq_in IN UT_TESTCASE.SEQ%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.SEQ%TYPE;

   FUNCTION description$frc
      (description_in IN UT_TESTCASE.DESCRIPTION%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.DESCRIPTION%TYPE;

   FUNCTION status$frc
      (status_in IN UT_TESTCASE.STATUS%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.STATUS%TYPE;

   FUNCTION declarations$frc
      (declarations_in IN UT_TESTCASE.DECLARATIONS%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.DECLARATIONS%TYPE;

   FUNCTION setup$frc
      (setup_in IN UT_TESTCASE.SETUP%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.SETUP%TYPE;

   FUNCTION teardown$frc
      (teardown_in IN UT_TESTCASE.TEARDOWN%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.TEARDOWN%TYPE;

   FUNCTION exceptions$frc
      (exceptions_in IN UT_TESTCASE.EXCEPTIONS%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.EXCEPTIONS%TYPE;

   FUNCTION test_id$frc
      (test_id_in IN UT_TESTCASE.TEST_ID%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.TEST_ID%TYPE;

   FUNCTION prefix$frc
      (prefix_in IN UT_TESTCASE.PREFIX%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.PREFIX%TYPE;

   FUNCTION assertion$frc
      (assertion_in IN UT_TESTCASE.ASSERTION%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.ASSERTION%TYPE;

   FUNCTION inline_assertion_call$frc
      (inline_assertion_call_in IN UT_TESTCASE.INLINE_ASSERTION_CALL%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.INLINE_ASSERTION_CALL%TYPE;

   FUNCTION executions$frc
      (executions_in IN UT_TESTCASE.EXECUTIONS%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.EXECUTIONS%TYPE;

   FUNCTION failures$frc
      (failures_in IN UT_TESTCASE.FAILURES%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.FAILURES%TYPE;

   FUNCTION last_start$frc
      (last_start_in IN UT_TESTCASE.LAST_START%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.LAST_START%TYPE;

   FUNCTION last_end$frc
      (last_end_in IN UT_TESTCASE.LAST_END%TYPE DEFAULT NULL)
      RETURN UT_TESTCASE.LAST_END%TYPE;

   PROCEDURE upd (
      id_in IN UT_TESTCASE.ID%TYPE,
      unittest_id_in IN UT_TESTCASE.UNITTEST_ID%TYPE DEFAULT NULL,
      name_in IN UT_TESTCASE.NAME%TYPE DEFAULT NULL,
      seq_in IN UT_TESTCASE.SEQ%TYPE DEFAULT NULL,
      description_in IN UT_TESTCASE.DESCRIPTION%TYPE DEFAULT NULL,
      status_in IN UT_TESTCASE.STATUS%TYPE DEFAULT NULL,
      declarations_in IN UT_TESTCASE.DECLARATIONS%TYPE DEFAULT NULL,
      setup_in IN UT_TESTCASE.SETUP%TYPE DEFAULT NULL,
      teardown_in IN UT_TESTCASE.TEARDOWN%TYPE DEFAULT NULL,
      exceptions_in IN UT_TESTCASE.EXCEPTIONS%TYPE DEFAULT NULL,
      test_id_in IN UT_TESTCASE.TEST_ID%TYPE DEFAULT NULL,
      prefix_in IN UT_TESTCASE.PREFIX%TYPE DEFAULT NULL,
      assertion_in IN UT_TESTCASE.ASSERTION%TYPE DEFAULT NULL,
      inline_assertion_call_in IN UT_TESTCASE.INLINE_ASSERTION_CALL%TYPE DEFAULT NULL,
      executions_in IN UT_TESTCASE.EXECUTIONS%TYPE DEFAULT NULL,
      failures_in IN UT_TESTCASE.FAILURES%TYPE DEFAULT NULL,
      last_start_in IN UT_TESTCASE.LAST_START%TYPE DEFAULT NULL,
      last_end_in IN UT_TESTCASE.LAST_END%TYPE DEFAULT NULL,
      rowcount_out OUT INTEGER,
      reset_in IN BOOLEAN DEFAULT TRUE
      );

   --// Record-based Update //--

   PROCEDURE upd (rec_in IN UT_TESTCASE%ROWTYPE,
      rowcount_out OUT INTEGER,
      reset_in IN BOOLEAN DEFAULT TRUE);

--// Insert Processing //--

   --// Initialize record with default values. //--
   FUNCTION initrec (allnull IN BOOLEAN := FALSE) RETURN UT_TESTCASE%ROWTYPE;

   --// Initialize record with default values. //--
   PROCEDURE initrec (
      rec_inout IN OUT UT_TESTCASE%ROWTYPE,
      allnull IN BOOLEAN := FALSE);

   PROCEDURE ins (
      id_in IN UT_TESTCASE.ID%TYPE,
      unittest_id_in IN UT_TESTCASE.UNITTEST_ID%TYPE DEFAULT NULL,
      name_in IN UT_TESTCASE.NAME%TYPE DEFAULT NULL,
      seq_in IN UT_TESTCASE.SEQ%TYPE DEFAULT 1,
      description_in IN UT_TESTCASE.DESCRIPTION%TYPE DEFAULT NULL,
      status_in IN UT_TESTCASE.STATUS%TYPE DEFAULT NULL,
      declarations_in IN UT_TESTCASE.DECLARATIONS%TYPE DEFAULT NULL,
      setup_in IN UT_TESTCASE.SETUP%TYPE DEFAULT NULL,
      teardown_in IN UT_TESTCASE.TEARDOWN%TYPE DEFAULT NULL,
      exceptions_in IN UT_TESTCASE.EXCEPTIONS%TYPE DEFAULT NULL,
      test_id_in IN UT_TESTCASE.TEST_ID%TYPE DEFAULT NULL,
      prefix_in IN UT_TESTCASE.PREFIX%TYPE DEFAULT NULL,
      assertion_in IN UT_TESTCASE.ASSERTION%TYPE DEFAULT NULL,
      inline_assertion_call_in IN UT_TESTCASE.INLINE_ASSERTION_CALL%TYPE DEFAULT 'N',
      executions_in IN UT_TESTCASE.EXECUTIONS%TYPE DEFAULT NULL,
      failures_in IN UT_TESTCASE.FAILURES%TYPE DEFAULT NULL,
      last_start_in IN UT_TESTCASE.LAST_START%TYPE DEFAULT NULL,
      last_end_in IN UT_TESTCASE.LAST_END%TYPE DEFAULT NULL,
      upd_on_dup IN BOOLEAN := FALSE
      );

   --// Record-based insert //--
   PROCEDURE ins (rec_in IN UT_TESTCASE%ROWTYPE,
      upd_on_dup IN BOOLEAN := FALSE
      );

--// Delete Processing //--
   PROCEDURE del (
      id_in IN UT_TESTCASE.ID%TYPE,
      rowcount_out OUT INTEGER);

   --// Record-based delete //--
   PROCEDURE del (rec_in IN pky_rt,
      rowcount_out OUT INTEGER);

   PROCEDURE del (rec_in IN UT_TESTCASE%ROWTYPE,
      rowcount_out OUT INTEGER);

   --// Delete all records for this UT_TESTCASE_UNITEST_FK foreign key. //--
   PROCEDURE delby_ut_testcase_unitest_fk (
      unittest_id_in IN UT_TESTCASE.UNITTEST_ID%TYPE,
      rowcount_out OUT INTEGER
      );

   --// Program called by database initialization script to pin the package. //--
   PROCEDURE pinme;
END te_ut_testcase;
/
/*
||------------------------------------------------------
|| PL/Generator Report on Invalid Identifiers
|| for package te_ut_testcase based on UT_TESTCASE
||------------------------------------------------------
|| The following list shows those identifiers which
|| were invalid (usually because the names were too
|| long). It also shows the corrected name that was
|| used in the code, as well as a description of the
|| purpose that code element serves in the package.
||------------------------------------------------------
|| Invalid: open_ut_testcase_unitest_fk_all_cur
||   New name: open_ut_testcase_unitest_fk_al
||    Purpose: "Opens cursor returning rows for foreign key"
||
|| Invalid: close_ut_testcase_unitest_fk_all_cur
||   New name: close_ut_testcase_unitest_fk_a
||    Purpose: "Closes cursor returning rows for foreign key"
||
||------------------------------------------------------
*/
