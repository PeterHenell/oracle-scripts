CREATE OR REPLACE PACKAGE ut_just_one
/*
| Unit Test Package for QU.JUST_ONE
|
| Generated on 2005-12-23 09:01:40
|
| Generated by Qute -- the Quick Unit Test Engine (www.unit-test.com)
|
| This package may be run from within any PL/SQL execution environment.
| by executing the following statements:
|
|    SET SERVEROUTPUT ON FORMAT WRAPPED SIZE 1000000
|
|    BEGIN
|       ut_dyn_placeholder.run_all_tests;
|    END;
|    /
|
| Results will be displayed via DBMS_OUTPUT. This package requires the
| presence of the qu_assert package. If you do not have Qute installed,
| you can download just the qu_assert package from:
|
|      http://www.unit-test.com/download/qu_assert.zip
|
| Then use the following statements to install all needed objects:
|
|    -- Assertion package
|    @qu_assert.pks
|    @qu_assert.pkb
|
|    -- Source code
|    @JUST_ONE.pks
|    @JUST_ONE.pkb
|
|    -- Test code
|    @UT_JUST_ONE.pkg
|
*/
IS
   PROCEDURE ut_setup;

   PROCEDURE ut_teardown;

   PROCEDURE ut_just_one;

   PROCEDURE run_all_tests;
END ut_just_one;
/

CREATE OR REPLACE PACKAGE BODY ut_just_one
/*
| Unit Test Package for QU.JUST_ONE
|
| Generated on 2005-12-23 09:01:41
|
| Generated by Qute -- the Quick Unit Test Engine (www.unit-test.com)
|
| This package may be run from within any PL/SQL execution environment.
| by executing the following statements:
|
|    SET SERVEROUTPUT ON FORMAT WRAPPED SIZE 1000000
|
|    BEGIN
|       ut_dyn_placeholder.run_all_tests;
|    END;
|    /
|
| Results will be displayed via DBMS_OUTPUT. This package requires the
| presence of the qu_assert package. If you do not have Qute installed,
| you can download just the qu_assert package from:
|
|      http://www.unit-test.com/download/qu_assert.zip
|
| Then use the following statements to install all needed objects:
|
|    -- Assertion package
|    @qu_assert.pks
|    @qu_assert.pkb
|
|    -- Source code
|    @JUST_ONE.pks
|    @JUST_ONE.pkb
|
|    -- Test code
|    @UT_JUST_ONE.pkg
|
*/
IS
   PROCEDURE ut_setup
   IS
   BEGIN
      NULL;  -- Included to ensure that this procedure will compile if empty.
   END ut_setup;

   PROCEDURE ut_teardown
   IS
   BEGIN
      NULL;  -- Included to ensure that this procedure will compile if empty.
   END ut_teardown;

   PROCEDURE ut_just_one
   -- Unit test procedure for JUST_ONE
   IS
      PROCEDURE pattern_at_beginning
      IS
         -- Local variables for all parameters (and RETURN value if a function)

         -- First the IN and IN OUT arguments...
         l_string_in VARCHAR2 ( 32767 );
         l_pattern_in VARCHAR2 ( 32767 );
         -- And now the RETURN and OUT arguments...
         "Value From Function" VARCHAR2 ( 32767 );
         -- Local variables for EXPECTED and FROM PROGRAM values for outcomes
         "Expected Value From Function" VARCHAR2 ( 32767 );
         "Actual Value From Function" VARCHAR2 ( 32767 );

         PROCEDURE setup
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END setup;

         PROCEDURE set_in_values
         IS
         BEGIN
            -- Assign values for each IN and IN OUT argument.
            l_string_in := 'ababcd';
            l_pattern_in := 'ab';
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_in_values;

         PROCEDURE set_expected_values
         IS
         BEGIN
            -- Assign values for each OUT and IN OUT argument.
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;

         PROCEDURE call_the_program
         IS
         BEGIN
            "Value From Function" :=
               just_one ( string_in       => l_string_in
                        , pattern_in      => l_pattern_in
                        );
            -- Copy value returned by function to all "from program" variables
            -- based on the function's RETURN clause.
            "Actual Value From Function" := "Value From Function";
         END call_the_program;

         PROCEDURE check_out_args_and_return
         IS
         BEGIN
            DBMS_OUTPUT.put_line ( '    Outcome "Value returned by function"' );
            qu_assert.eq ( outcome_guid_in      => 'N/A'
                         , check_this_in        => "Actual Value From Function"
                         , against_this_in      => 'abcd'
                         , raise_exc_in         => FALSE
                         , null_ok_in           => TRUE
                         , truncate_in          => FALSE
                         );
            NULL;
              -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;

         PROCEDURE teardown
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END teardown;
      BEGIN
         DBMS_OUTPUT.put_line ( '  Test case "Pattern at beginning"' );
         setup;
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
         teardown;
      END pattern_at_beginning;

      PROCEDURE pattern_at_end
      IS
         -- Local variables for all parameters (and RETURN value if a function)

         -- First the IN and IN OUT arguments...
         l_string_in VARCHAR2 ( 32767 );
         l_pattern_in VARCHAR2 ( 32767 );
         -- And now the RETURN and OUT arguments...
         "Value From Function" VARCHAR2 ( 32767 );
         -- Local variables for EXPECTED and FROM PROGRAM values for outcomes
         "Expected Value From Function" VARCHAR2 ( 32767 );
         "Actual Value From Function" VARCHAR2 ( 32767 );

         PROCEDURE setup
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END setup;

         PROCEDURE set_in_values
         IS
         BEGIN
            -- Assign values for each IN and IN OUT argument.
            l_string_in := 'abcdcd';
            l_pattern_in := 'cd';
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_in_values;

         PROCEDURE set_expected_values
         IS
         BEGIN
            -- Assign values for each OUT and IN OUT argument.
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;

         PROCEDURE call_the_program
         IS
         BEGIN
            "Value From Function" :=
               just_one ( string_in       => l_string_in
                        , pattern_in      => l_pattern_in
                        );
            -- Copy value returned by function to all "from program" variables
            -- based on the function's RETURN clause.
            "Actual Value From Function" := "Value From Function";
         END call_the_program;

         PROCEDURE check_out_args_and_return
         IS
         BEGIN
            DBMS_OUTPUT.put_line ( '    Outcome "Value returned by function"' );
            qu_assert.eq ( outcome_guid_in      => 'N/A'
                         , check_this_in        => "Actual Value From Function"
                         , against_this_in      => 'abcd'
                         , raise_exc_in         => FALSE
                         , null_ok_in           => TRUE
                         , truncate_in          => FALSE
                         );
            NULL;
              -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;

         PROCEDURE teardown
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END teardown;
      BEGIN
         DBMS_OUTPUT.put_line ( '  Test case "Pattern at end"' );
         setup;
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
         teardown;
      END pattern_at_end;

      PROCEDURE pattern_is_null
      IS
         -- Local variables for all parameters (and RETURN value if a function)

         -- First the IN and IN OUT arguments...
         l_string_in VARCHAR2 ( 32767 );
         l_pattern_in VARCHAR2 ( 32767 );
         -- And now the RETURN and OUT arguments...
         "Value From Function" VARCHAR2 ( 32767 );
         -- Local variables for EXPECTED and FROM PROGRAM values for outcomes
         "Expected Value From Function" VARCHAR2 ( 32767 );
         "Actual Value From Function" VARCHAR2 ( 32767 );

         PROCEDURE setup
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END setup;

         PROCEDURE set_in_values
         IS
         BEGIN
            -- Assign values for each IN and IN OUT argument.
            l_string_in := 'abc';
            l_pattern_in := NULL;
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_in_values;

         PROCEDURE set_expected_values
         IS
         BEGIN
            -- Assign values for each OUT and IN OUT argument.
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;

         PROCEDURE call_the_program
         IS
         BEGIN
            "Value From Function" :=
               just_one ( string_in       => l_string_in
                        , pattern_in      => l_pattern_in
                        );
            -- Copy value returned by function to all "from program" variables
            -- based on the function's RETURN clause.
            "Actual Value From Function" := "Value From Function";
         END call_the_program;

         PROCEDURE check_out_args_and_return
         IS
         BEGIN
            DBMS_OUTPUT.put_line
               ( '    Outcome "Pattern is null, then return original string unchanged"'
               );
            qu_assert.eq ( outcome_guid_in      => 'N/A'
                         , check_this_in        => "Actual Value From Function"
                         , against_this_in      => 'abc'
                         , raise_exc_in         => FALSE
                         , null_ok_in           => TRUE
                         , truncate_in          => FALSE
                         );
            NULL;
              -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;

         PROCEDURE teardown
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END teardown;
      BEGIN
         DBMS_OUTPUT.put_line ( '  Test case "Pattern is null"' );
         setup;
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
         teardown;
      END pattern_is_null;

      PROCEDURE pattern_not_in_string
      IS
         -- Local variables for all parameters (and RETURN value if a function)

         -- First the IN and IN OUT arguments...
         l_string_in VARCHAR2 ( 32767 );
         l_pattern_in VARCHAR2 ( 32767 );
         -- And now the RETURN and OUT arguments...
         "Value From Function" VARCHAR2 ( 32767 );
         -- Local variables for EXPECTED and FROM PROGRAM values for outcomes
         "Expected Value From Function" VARCHAR2 ( 32767 );
         "Actual Value From Function" VARCHAR2 ( 32767 );

         PROCEDURE setup
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END setup;

         PROCEDURE set_in_values
         IS
         BEGIN
            -- Assign values for each IN and IN OUT argument.
            l_string_in := 'abc';
            l_pattern_in := '4';
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_in_values;

         PROCEDURE set_expected_values
         IS
         BEGIN
            -- Assign values for each OUT and IN OUT argument.
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;

         PROCEDURE call_the_program
         IS
         BEGIN
            "Value From Function" :=
               just_one ( string_in       => l_string_in
                        , pattern_in      => l_pattern_in
                        );
            -- Copy value returned by function to all "from program" variables
            -- based on the function's RETURN clause.
            "Actual Value From Function" := "Value From Function";
         END call_the_program;

         PROCEDURE check_out_args_and_return
         IS
         BEGIN
            DBMS_OUTPUT.put_line ( '    Outcome "Value returned by function"' );
            qu_assert.eq ( outcome_guid_in      => 'N/A'
                         , check_this_in        => "Actual Value From Function"
                         , against_this_in      => 'abc'
                         , raise_exc_in         => FALSE
                         , null_ok_in           => TRUE
                         , truncate_in          => FALSE
                         );
            NULL;
              -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;

         PROCEDURE teardown
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END teardown;
      BEGIN
         DBMS_OUTPUT.put_line ( '  Test case "Pattern not in string"' );
         setup;
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
         teardown;
      END pattern_not_in_string;

      PROCEDURE pattern_repeats_in_different_p
      IS
         -- Local variables for all parameters (and RETURN value if a function)

         -- First the IN and IN OUT arguments...
         l_string_in VARCHAR2 ( 32767 );
         l_pattern_in VARCHAR2 ( 32767 );
         -- And now the RETURN and OUT arguments...
         "Value From Function" VARCHAR2 ( 32767 );
         -- Local variables for EXPECTED and FROM PROGRAM values for outcomes
         "Expected Value From Function" VARCHAR2 ( 32767 );
         "Actual Value From Function" VARCHAR2 ( 32767 );

         PROCEDURE setup
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END setup;

         PROCEDURE set_in_values
         IS
         BEGIN
            -- Assign values for each IN and IN OUT argument.
            l_string_in := 'abcdcd123cdcd456';
            l_pattern_in := 'cd';
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_in_values;

         PROCEDURE set_expected_values
         IS
         BEGIN
            -- Assign values for each OUT and IN OUT argument.
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;

         PROCEDURE call_the_program
         IS
         BEGIN
            "Value From Function" :=
               just_one ( string_in       => l_string_in
                        , pattern_in      => l_pattern_in
                        );
            -- Copy value returned by function to all "from program" variables
            -- based on the function's RETURN clause.
            "Actual Value From Function" := "Value From Function";
         END call_the_program;

         PROCEDURE check_out_args_and_return
         IS
         BEGIN
            DBMS_OUTPUT.put_line ( '    Outcome "Value returned by function"' );
            qu_assert.eq ( outcome_guid_in      => 'N/A'
                         , check_this_in        => "Actual Value From Function"
                         , against_this_in      => 'abcd123cd456'
                         , raise_exc_in         => FALSE
                         , null_ok_in           => TRUE
                         , truncate_in          => FALSE
                         );
            NULL;
              -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;

         PROCEDURE teardown
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END teardown;
      BEGIN
         DBMS_OUTPUT.put_line
               ( '  Test case "Pattern repeats in different parts of string"' );
         setup;
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
         teardown;
      END pattern_repeats_in_different_p;

      PROCEDURE pattern_repeats_once_together
      IS
         -- Local variables for all parameters (and RETURN value if a function)

         -- First the IN and IN OUT arguments...
         l_string_in VARCHAR2 ( 32767 );
         l_pattern_in VARCHAR2 ( 32767 );
         -- And now the RETURN and OUT arguments...
         "Value From Function" VARCHAR2 ( 32767 );
         -- Local variables for EXPECTED and FROM PROGRAM values for outcomes
         "Expected Value From Function" VARCHAR2 ( 32767 );
         "Actual Value From Function" VARCHAR2 ( 32767 );

         PROCEDURE setup
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END setup;

         PROCEDURE set_in_values
         IS
         BEGIN
            -- Assign values for each IN and IN OUT argument.
            l_string_in := 'abcdcdef';
            l_pattern_in := 'cd';
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_in_values;

         PROCEDURE set_expected_values
         IS
         BEGIN
            -- Assign values for each OUT and IN OUT argument.
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;

         PROCEDURE call_the_program
         IS
         BEGIN
            "Value From Function" :=
               just_one ( string_in       => l_string_in
                        , pattern_in      => l_pattern_in
                        );
            -- Copy value returned by function to all "from program" variables
            -- based on the function's RETURN clause.
            "Actual Value From Function" := "Value From Function";
         END call_the_program;

         PROCEDURE check_out_args_and_return
         IS
         BEGIN
            DBMS_OUTPUT.put_line ( '    Outcome "Value returned by function"' );
            qu_assert.eq ( outcome_guid_in      => 'N/A'
                         , check_this_in        => "Actual Value From Function"
                         , against_this_in      => 'abcdef'
                         , raise_exc_in         => FALSE
                         , null_ok_in           => TRUE
                         , truncate_in          => FALSE
                         );
            NULL;
              -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;

         PROCEDURE teardown
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END teardown;
      BEGIN
         DBMS_OUTPUT.put_line
                             ( '  Test case "Pattern repeats once, together"' );
         setup;
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
         teardown;
      END pattern_repeats_once_together;

      PROCEDURE string_is_null
      IS
         -- Local variables for all parameters (and RETURN value if a function)

         -- First the IN and IN OUT arguments...
         l_string_in VARCHAR2 ( 32767 );
         l_pattern_in VARCHAR2 ( 32767 );
         -- And now the RETURN and OUT arguments...
         "Value From Function" VARCHAR2 ( 32767 );
         -- Local variables for EXPECTED and FROM PROGRAM values for outcomes
         "Actual Value From Function" VARCHAR2 ( 32767 );

         PROCEDURE setup
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END setup;

         PROCEDURE set_in_values
         IS
         BEGIN
            -- Assign values for each IN and IN OUT argument.
            l_string_in := NULL;
            l_pattern_in := 'ab';
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_in_values;

         PROCEDURE set_expected_values
         IS
         BEGIN
            -- Assign values for each OUT and IN OUT argument.
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END set_expected_values;

         PROCEDURE call_the_program
         IS
         BEGIN
            "Value From Function" :=
               just_one ( string_in       => l_string_in
                        , pattern_in      => l_pattern_in
                        );
            -- Copy value returned by function to all "from program" variables
            -- based on the function's RETURN clause.
            "Actual Value From Function" := "Value From Function";
         END call_the_program;

         PROCEDURE check_out_args_and_return
         IS
         BEGIN
            DBMS_OUTPUT.put_line
                           ( '    Outcome "String is null, then return NULL"' );
            qu_assert.isnull ( outcome_guid_in      => 'N/A'
                             , check_this_in        => "Actual Value From Function"
                             , raise_exc_in         => FALSE
                             );
            NULL;
              -- Included to ensure that this procedure will compile if empty.
         END check_out_args_and_return;

         PROCEDURE teardown
         IS
         BEGIN
            NULL;
             -- Included to ensure that this procedure will compile if empty.
         END teardown;
      BEGIN
         DBMS_OUTPUT.put_line ( '  Test case "String is null"' );
         setup;
         set_in_values;
         set_expected_values;
         call_the_program;
         check_out_args_and_return;
         teardown;
      END string_is_null;
   BEGIN
      DBMS_OUTPUT.put_line ( 'Testing "JUST_ONE"' );
      pattern_at_beginning;
      pattern_at_end;
      pattern_is_null;
      pattern_not_in_string;
      pattern_repeats_in_different_p;
      pattern_repeats_once_together;
      string_is_null;
      NULL;  -- Included to ensure that this procedure will compile if empty.
   END ut_just_one;

   PROCEDURE run_all_tests
   IS
   BEGIN
      qu_assert.set_current_harness_info ( NULL, TRUE );
      ut_setup;
      ut_just_one;
      ut_teardown;
      qu_assert.set_current_harness_info ( NULL, NULL );
   END run_all_tests;
END ut_just_one;
/
