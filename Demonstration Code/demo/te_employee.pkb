CREATE OR REPLACE PACKAGE BODY te_employee
--//-----------------------------------------------------------------------
--//  ** PL/Generator Table Encapsulator for "EMPLOYEE"
--//-----------------------------------------------------------------------
--//  (c) COPYRIGHT  2003.
--//               All rights reserved.
--//
--//  No part of this copyrighted work may be reproduced, modified,
--//  or distributed in any form or by any means without the prior
--//  written permission of .
--//-----------------------------------------------------------------------
--//  This software was generated by Quest Software's PL/Generator (TM).
--//
--//  For more information, visit www.Quest Software.com or call 1.800.REVEAL4
--//-----------------------------------------------------------------------
--//  Stored In:  te_employee.pkb
--//  Created On: January   06, 2003 17:02:48
--//  Created By: SCOTT
--//  PL/Generator Version: PRO-2000.2.8
--//-----------------------------------------------------------------------
IS
   --// Package name and program name globals --//
   c_pkgname VARCHAR2(30) := 'te_employee';
   g_progname VARCHAR2(30) := NULL;

   --// Update Flag private data structures. --//
   TYPE frcflg_rt IS RECORD (
      last_name CHAR(1),
      first_name CHAR(1),
      middle_initial CHAR(1),
      job_id CHAR(1),
      manager_id CHAR(1),
      hire_date CHAR(1),
      salary CHAR(1),
      commission CHAR(1),
      department_id CHAR(1),
      empno CHAR(1),
      ename CHAR(1),
      created_by CHAR(1),
      created_on CHAR(1),
      changed_by CHAR(1),
      changed_on CHAR(1)
      );

   frcflg frcflg_rt;
   emptyfrc frcflg_rt;
   c_set CHAR(1) := 'Y';
   c_noset CHAR(1) := 'N';

--// Private Modules //--

   --// For Dynamic SQL operations; currently unused. //--
   PROCEDURE initcur (cur_inout IN OUT INTEGER)
   IS
   BEGIN
      IF NOT DBMS_SQL.IS_OPEN (cur_inout)
      THEN
         cur_inout := DBMS_SQL.OPEN_CURSOR;
      END IF;
   EXCEPTION
      WHEN invalid_cursor
      THEN
         cur_inout := DBMS_SQL.OPEN_CURSOR;
   END;

   PROCEDURE start_program (nm IN VARCHAR2, msg IN VARCHAR2 := NULL) IS
   BEGIN
      g_progname := nm;
   END;

   PROCEDURE end_program IS
   BEGIN
      g_progname := NULL;
   END;

--// Cursor management procedures //--

   --// Open the cursors with some options. //--
   PROCEDURE open_allforpky_cur (
      employee_id_in IN EMPLOYEE.EMPLOYEE_ID%TYPE,
      close_if_open IN BOOLEAN := TRUE
      )
   IS
      v_close BOOLEAN := NVL (close_if_open, TRUE);
      v_open BOOLEAN := TRUE;
   BEGIN
      start_program ('open_allforpky_cur');

      IF allforpky_cur%ISOPEN AND v_close
      THEN
         CLOSE allforpky_cur;
      ELSIF allforpky_cur%ISOPEN AND NOT v_close
      THEN
         v_open := FALSE;
      END IF;

      IF v_open
      THEN
          OPEN allforpky_cur (
             employee_id_in
             );
      END IF;

      end_program;
   END;

   PROCEDURE open_allbypky_cur (
      close_if_open IN BOOLEAN := TRUE
      )
   IS
      v_close BOOLEAN := NVL (close_if_open, TRUE);
      v_open BOOLEAN := TRUE;
   BEGIN
      IF allbypky_cur%ISOPEN AND v_close
      THEN
         CLOSE allbypky_cur;
      ELSIF allbypky_cur%ISOPEN AND NOT v_close
      THEN
         v_open := FALSE;
      END IF;

      IF v_open
      THEN
         OPEN allbypky_cur;
      END IF;
   END;

   --// Close the cursors if they are open. //--
   PROCEDURE close_allforpky_cur
   IS BEGIN
      IF allforpky_cur%ISOPEN
      THEN
         CLOSE allforpky_cur;
      END IF;
   END;

   PROCEDURE close_allbypky_cur
   IS BEGIN
      IF allbypky_cur%ISOPEN
      THEN
         CLOSE allbypky_cur;
      END IF;
   END;

   PROCEDURE closeall
   IS
   BEGIN
      close_allforpky_cur;
      close_allbypky_cur;
   END;

--// Emulate aggregate-level record operations. //--

   FUNCTION recseq (rec1 IN EMPLOYEE%ROWTYPE, rec2 IN EMPLOYEE%ROWTYPE)
   RETURN BOOLEAN
   IS
      unequal_records EXCEPTION;
      retval BOOLEAN;
   BEGIN
      retval := rec1.EMPLOYEE_ID = rec2.EMPLOYEE_ID OR
         (rec1.EMPLOYEE_ID IS NULL AND rec2.EMPLOYEE_ID IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.LAST_NAME = rec2.LAST_NAME OR
         (rec1.LAST_NAME IS NULL AND rec2.LAST_NAME IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.FIRST_NAME = rec2.FIRST_NAME OR
         (rec1.FIRST_NAME IS NULL AND rec2.FIRST_NAME IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.MIDDLE_INITIAL = rec2.MIDDLE_INITIAL OR
         (rec1.MIDDLE_INITIAL IS NULL AND rec2.MIDDLE_INITIAL IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.JOB_ID = rec2.JOB_ID OR
         (rec1.JOB_ID IS NULL AND rec2.JOB_ID IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.MANAGER_ID = rec2.MANAGER_ID OR
         (rec1.MANAGER_ID IS NULL AND rec2.MANAGER_ID IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.HIRE_DATE = rec2.HIRE_DATE OR
         (rec1.HIRE_DATE IS NULL AND rec2.HIRE_DATE IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.SALARY = rec2.SALARY OR
         (rec1.SALARY IS NULL AND rec2.SALARY IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.COMMISSION = rec2.COMMISSION OR
         (rec1.COMMISSION IS NULL AND rec2.COMMISSION IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.DEPARTMENT_ID = rec2.DEPARTMENT_ID OR
         (rec1.DEPARTMENT_ID IS NULL AND rec2.DEPARTMENT_ID IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.EMPNO = rec2.EMPNO OR
         (rec1.EMPNO IS NULL AND rec2.EMPNO IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.ENAME = rec2.ENAME OR
         (rec1.ENAME IS NULL AND rec2.ENAME IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.CREATED_BY = rec2.CREATED_BY OR
         (rec1.CREATED_BY IS NULL AND rec2.CREATED_BY IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.CREATED_ON = rec2.CREATED_ON OR
         (rec1.CREATED_ON IS NULL AND rec2.CREATED_ON IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.CHANGED_BY = rec2.CHANGED_BY OR
         (rec1.CHANGED_BY IS NULL AND rec2.CHANGED_BY IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      retval := rec1.CHANGED_ON = rec2.CHANGED_ON OR
         (rec1.CHANGED_ON IS NULL AND rec2.CHANGED_ON IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      RETURN TRUE;
   EXCEPTION
      WHEN unequal_records THEN RETURN FALSE;
   END;

   FUNCTION recseq (rec1 IN pky_rt, rec2 IN pky_rt)
   RETURN BOOLEAN
   IS
      unequal_records EXCEPTION;
      retval BOOLEAN;
   BEGIN
      retval := rec1.employee_id = rec2.employee_id OR
         (rec1.employee_id IS NULL AND rec2.employee_id IS NULL);
      IF NOT NVL (retval, FALSE) THEN RAISE unequal_records; END IF;
      RETURN TRUE;
   EXCEPTION
      WHEN unequal_records THEN RETURN FALSE;
   END;

--// Is the primary key NOT NULL? //--

   FUNCTION isnullpky (
      rec_in IN EMPLOYEE%ROWTYPE
      )
   RETURN BOOLEAN
   IS
   BEGIN
      RETURN
         rec_in.EMPLOYEE_ID IS NULL
         ;
   END;

   FUNCTION isnullpky (
      rec_in IN pky_rt
      )
   RETURN BOOLEAN
   IS
   BEGIN
      RETURN
         rec_in.employee_id IS NULL
         ;
   END;

--// Query Processing --//

   FUNCTION onerow_internal (
      employee_id_in IN EMPLOYEE.EMPLOYEE_ID%TYPE
      )
   RETURN EMPLOYEE%ROWTYPE
   IS
      CURSOR onerow_cur
      IS
         SELECT
            EMPLOYEE_ID,
            LAST_NAME,
            FIRST_NAME,
            MIDDLE_INITIAL,
            JOB_ID,
            MANAGER_ID,
            HIRE_DATE,
            SALARY,
            COMMISSION,
            DEPARTMENT_ID,
            EMPNO,
            ENAME,
            CREATED_BY,
            CREATED_ON,
            CHANGED_BY,
            CHANGED_ON
           FROM EMPLOYEE
          WHERE
             EMPLOYEE_ID = employee_id_in
      ;
      onerow_rec EMPLOYEE%ROWTYPE;
   BEGIN
      OPEN onerow_cur;
      FETCH onerow_cur INTO onerow_rec;
      CLOSE onerow_cur;
      RETURN onerow_rec;
   END onerow_internal;

   FUNCTION onerow (
      employee_id_in IN EMPLOYEE.EMPLOYEE_ID%TYPE
      )
   RETURN EMPLOYEE%ROWTYPE
   IS
      retval EMPLOYEE%ROWTYPE;
   BEGIN
      retval := onerow_internal (
         employee_id_in
         );
      RETURN retval;
   END onerow;

   FUNCTION i_employee_name$pky (
      last_name_in IN EMPLOYEE.LAST_NAME%TYPE,
      first_name_in IN EMPLOYEE.FIRST_NAME%TYPE,
      middle_initial_in IN EMPLOYEE.MIDDLE_INITIAL%TYPE
      )
      RETURN pky_rt
   IS
      CURSOR getpky_cur
      IS
         SELECT
            EMPLOYEE_ID
           FROM EMPLOYEE
          WHERE
            LAST_NAME = i_employee_name$pky.last_name_in AND
            FIRST_NAME = i_employee_name$pky.first_name_in AND
            MIDDLE_INITIAL = i_employee_name$pky.middle_initial_in
            ;

      getpky_rec getpky_cur%ROWTYPE;
      retval pky_rt;
   BEGIN
      OPEN getpky_cur;
      FETCH getpky_cur INTO getpky_rec;
      IF getpky_cur%FOUND
      THEN
         retval.employee_id := getpky_rec.EMPLOYEE_ID;
      END IF;
      CLOSE getpky_cur;
      RETURN retval;
   END i_employee_name$pky;

   FUNCTION i_employee_name$row (
      last_name_in IN EMPLOYEE.LAST_NAME%TYPE,
      first_name_in IN EMPLOYEE.FIRST_NAME%TYPE,
      middle_initial_in IN EMPLOYEE.MIDDLE_INITIAL%TYPE
      )
   RETURN EMPLOYEE%ROWTYPE
   IS
      CURSOR onerow_cur
      IS
         SELECT
            EMPLOYEE_ID,
            LAST_NAME,
            FIRST_NAME,
            MIDDLE_INITIAL,
            JOB_ID,
            MANAGER_ID,
            HIRE_DATE,
            SALARY,
            COMMISSION,
            DEPARTMENT_ID,
            EMPNO,
            ENAME,
            CREATED_BY,
            CREATED_ON,
            CHANGED_BY,
            CHANGED_ON
           FROM EMPLOYEE
          WHERE
             LAST_NAME = i_employee_name$row.last_name_in AND
             FIRST_NAME = i_employee_name$row.first_name_in AND
             MIDDLE_INITIAL = i_employee_name$row.middle_initial_in
             ;
      onerow_rec EMPLOYEE%ROWTYPE;
   BEGIN
      OPEN onerow_cur;
      FETCH onerow_cur INTO onerow_rec;
      CLOSE onerow_cur;
      RETURN onerow_rec;
   END i_employee_name$row;

   FUNCTION i_employee_name$val (
      employee_id_in IN EMPLOYEE.EMPLOYEE_ID%TYPE
      )
   RETURN i_employee_name_rt
   IS
      v_onerow EMPLOYEE%ROWTYPE;
      retval i_employee_name_rt;
   BEGIN
      v_onerow := onerow (
         employee_id_in
         );

      retval.last_name := v_onerow.LAST_NAME;
      retval.first_name := v_onerow.FIRST_NAME;
      retval.middle_initial := v_onerow.MIDDLE_INITIAL;

      RETURN retval;
   END i_employee_name$val;


   --// Count of all rows in table and for each foreign key. //--
   FUNCTION rowcount RETURN INTEGER
   IS
      retval INTEGER;
   BEGIN
      SELECT COUNT(*) INTO retval FROM EMPLOYEE;
      RETURN retval;
   END;

   FUNCTION pkyrowcount (
      employee_id_in IN EMPLOYEE.EMPLOYEE_ID%TYPE
      )
      RETURN INTEGER
   IS
      retval INTEGER;
   BEGIN
      SELECT COUNT(*)
        INTO retval
        FROM EMPLOYEE
       WHERE
         EMPLOYEE_ID = employee_id_in
         ;
      RETURN retval;
   END;


--// Check Constraint Validation --//

   --// Check Constraint: "HIRE_DATE" IS NOT NULL --//
   FUNCTION sys_c003090$chk (
      hire_date_in IN EMPLOYEE.HIRE_DATE%TYPE
      ) RETURN BOOLEAN
   IS
   BEGIN
      RETURN (HIRE_DATE_in IS NOT NULL);
   END sys_c003090$chk;

   --// Check Constraint: "CREATED_BY" IS NOT NULL --//
   FUNCTION sys_c003091$chk (
      created_by_in IN EMPLOYEE.CREATED_BY%TYPE
      ) RETURN BOOLEAN
   IS
   BEGIN
      RETURN (CREATED_BY_in IS NOT NULL);
   END sys_c003091$chk;

   --// Check Constraint: "CREATED_ON" IS NOT NULL --//
   FUNCTION sys_c003092$chk (
      created_on_in IN EMPLOYEE.CREATED_ON%TYPE
      ) RETURN BOOLEAN
   IS
   BEGIN
      RETURN (CREATED_ON_in IS NOT NULL);
   END sys_c003092$chk;

   --// Check Constraint: "CHANGED_BY" IS NOT NULL --//
   FUNCTION sys_c003093$chk (
      changed_by_in IN EMPLOYEE.CHANGED_BY%TYPE
      ) RETURN BOOLEAN
   IS
   BEGIN
      RETURN (CHANGED_BY_in IS NOT NULL);
   END sys_c003093$chk;

   --// Check Constraint: "CHANGED_ON" IS NOT NULL --//
   FUNCTION sys_c003094$chk (
      changed_on_in IN EMPLOYEE.CHANGED_ON%TYPE
      ) RETURN BOOLEAN
   IS
   BEGIN
      RETURN (CHANGED_ON_in IS NOT NULL);
   END sys_c003094$chk;

   PROCEDURE validate (
      hire_date_in IN EMPLOYEE.HIRE_DATE%TYPE,
      created_by_in IN EMPLOYEE.CREATED_BY%TYPE,
      created_on_in IN EMPLOYEE.CREATED_ON%TYPE,
      changed_by_in IN EMPLOYEE.CHANGED_BY%TYPE,
      changed_on_in IN EMPLOYEE.CHANGED_ON%TYPE,
      record_error IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      IF NOT sys_c003090$chk (
         hire_date_in
         )
      THEN
         --//** General mechanism! //--
         RAISE_APPLICATION_ERROR (-20000, 'ORA-2290: CHECK CONSTRAINT (sys_c003090) FAILED!');
      END IF;
      IF NOT sys_c003091$chk (
         created_by_in
         )
      THEN
         --//** General mechanism! //--
         RAISE_APPLICATION_ERROR (-20000, 'ORA-2290: CHECK CONSTRAINT (sys_c003091) FAILED!');
      END IF;
      IF NOT sys_c003092$chk (
         created_on_in
         )
      THEN
         --//** General mechanism! //--
         RAISE_APPLICATION_ERROR (-20000, 'ORA-2290: CHECK CONSTRAINT (sys_c003092) FAILED!');
      END IF;
      IF NOT sys_c003093$chk (
         changed_by_in
         )
      THEN
         --//** General mechanism! //--
         RAISE_APPLICATION_ERROR (-20000, 'ORA-2290: CHECK CONSTRAINT (sys_c003093) FAILED!');
      END IF;
      IF NOT sys_c003094$chk (
         changed_on_in
         )
      THEN
         --//** General mechanism! //--
         RAISE_APPLICATION_ERROR (-20000, 'ORA-2290: CHECK CONSTRAINT (sys_c003094) FAILED!');
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         IF record_error
         THEN
            RAISE;
         END IF;
         RAISE;
   END validate;

   PROCEDURE validate (
      rec_in IN EMPLOYEE%ROWTYPE,
      record_error IN BOOLEAN := TRUE
      )
   IS
   BEGIN
      validate (
         rec_in.HIRE_DATE,
         rec_in.CREATED_BY,
         rec_in.CREATED_ON,
         rec_in.CHANGED_BY,
         rec_in.CHANGED_ON,
         record_error
         );
   END validate;
--// Update Processing --//

   PROCEDURE reset$frc IS
   BEGIN
      frcflg := emptyfrc;
   END reset$frc;

   FUNCTION last_name$frc (last_name_in IN EMPLOYEE.LAST_NAME%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.LAST_NAME%TYPE
   IS
   BEGIN
      frcflg.last_name := c_set;
      RETURN last_name_in;
   END last_name$frc;

   FUNCTION first_name$frc (first_name_in IN EMPLOYEE.FIRST_NAME%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.FIRST_NAME%TYPE
   IS
   BEGIN
      frcflg.first_name := c_set;
      RETURN first_name_in;
   END first_name$frc;

   FUNCTION middle_initial$frc (middle_initial_in IN EMPLOYEE.MIDDLE_INITIAL%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.MIDDLE_INITIAL%TYPE
   IS
   BEGIN
      frcflg.middle_initial := c_set;
      RETURN middle_initial_in;
   END middle_initial$frc;

   FUNCTION job_id$frc (job_id_in IN EMPLOYEE.JOB_ID%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.JOB_ID%TYPE
   IS
   BEGIN
      frcflg.job_id := c_set;
      RETURN job_id_in;
   END job_id$frc;

   FUNCTION manager_id$frc (manager_id_in IN EMPLOYEE.MANAGER_ID%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.MANAGER_ID%TYPE
   IS
   BEGIN
      frcflg.manager_id := c_set;
      RETURN manager_id_in;
   END manager_id$frc;

   FUNCTION hire_date$frc (hire_date_in IN EMPLOYEE.HIRE_DATE%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.HIRE_DATE%TYPE
   IS
   BEGIN
      frcflg.hire_date := c_set;
      RETURN hire_date_in;
   END hire_date$frc;

   FUNCTION salary$frc (salary_in IN EMPLOYEE.SALARY%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.SALARY%TYPE
   IS
   BEGIN
      frcflg.salary := c_set;
      RETURN salary_in;
   END salary$frc;

   FUNCTION commission$frc (commission_in IN EMPLOYEE.COMMISSION%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.COMMISSION%TYPE
   IS
   BEGIN
      frcflg.commission := c_set;
      RETURN commission_in;
   END commission$frc;

   FUNCTION department_id$frc (department_id_in IN EMPLOYEE.DEPARTMENT_ID%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.DEPARTMENT_ID%TYPE
   IS
   BEGIN
      frcflg.department_id := c_set;
      RETURN department_id_in;
   END department_id$frc;

   FUNCTION empno$frc (empno_in IN EMPLOYEE.EMPNO%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.EMPNO%TYPE
   IS
   BEGIN
      frcflg.empno := c_set;
      RETURN empno_in;
   END empno$frc;

   FUNCTION ename$frc (ename_in IN EMPLOYEE.ENAME%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.ENAME%TYPE
   IS
   BEGIN
      frcflg.ename := c_set;
      RETURN ename_in;
   END ename$frc;

   FUNCTION created_by$frc (created_by_in IN EMPLOYEE.CREATED_BY%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.CREATED_BY%TYPE
   IS
   BEGIN
      frcflg.created_by := c_set;
      RETURN created_by_in;
   END created_by$frc;

   FUNCTION created_on$frc (created_on_in IN EMPLOYEE.CREATED_ON%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.CREATED_ON%TYPE
   IS
   BEGIN
      frcflg.created_on := c_set;
      RETURN created_on_in;
   END created_on$frc;

   FUNCTION changed_by$frc (changed_by_in IN EMPLOYEE.CHANGED_BY%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.CHANGED_BY%TYPE
   IS
   BEGIN
      frcflg.changed_by := c_set;
      RETURN changed_by_in;
   END changed_by$frc;

   FUNCTION changed_on$frc (changed_on_in IN EMPLOYEE.CHANGED_ON%TYPE DEFAULT NULL)
      RETURN EMPLOYEE.CHANGED_ON%TYPE
   IS
   BEGIN
      frcflg.changed_on := c_set;
      RETURN changed_on_in;
   END changed_on$frc;

   PROCEDURE upd (
      employee_id_in IN EMPLOYEE.EMPLOYEE_ID%TYPE,
      last_name_in IN EMPLOYEE.LAST_NAME%TYPE DEFAULT NULL,
      first_name_in IN EMPLOYEE.FIRST_NAME%TYPE DEFAULT NULL,
      middle_initial_in IN EMPLOYEE.MIDDLE_INITIAL%TYPE DEFAULT NULL,
      job_id_in IN EMPLOYEE.JOB_ID%TYPE DEFAULT NULL,
      manager_id_in IN EMPLOYEE.MANAGER_ID%TYPE DEFAULT NULL,
      hire_date_in IN EMPLOYEE.HIRE_DATE%TYPE DEFAULT NULL,
      salary_in IN EMPLOYEE.SALARY%TYPE DEFAULT NULL,
      commission_in IN EMPLOYEE.COMMISSION%TYPE DEFAULT NULL,
      department_id_in IN EMPLOYEE.DEPARTMENT_ID%TYPE DEFAULT NULL,
      empno_in IN EMPLOYEE.EMPNO%TYPE DEFAULT NULL,
      ename_in IN EMPLOYEE.ENAME%TYPE DEFAULT NULL,
      created_by_in IN EMPLOYEE.CREATED_BY%TYPE DEFAULT NULL,
      created_on_in IN EMPLOYEE.CREATED_ON%TYPE DEFAULT NULL,
      changed_by_in IN EMPLOYEE.CHANGED_BY%TYPE DEFAULT NULL,
      changed_on_in IN EMPLOYEE.CHANGED_ON%TYPE DEFAULT NULL,
      rowcount_out OUT INTEGER,
      reset_in IN BOOLEAN DEFAULT TRUE
      )
   IS
   BEGIN
      UPDATE EMPLOYEE SET
         LAST_NAME = DECODE (frcflg.last_name, c_set, last_name_in,
            NVL (last_name_in, LAST_NAME)),
         FIRST_NAME = DECODE (frcflg.first_name, c_set, first_name_in,
            NVL (first_name_in, FIRST_NAME)),
         MIDDLE_INITIAL = DECODE (frcflg.middle_initial, c_set, middle_initial_in,
            NVL (middle_initial_in, MIDDLE_INITIAL)),
         JOB_ID = DECODE (frcflg.job_id, c_set, job_id_in,
            NVL (job_id_in, JOB_ID)),
         MANAGER_ID = DECODE (frcflg.manager_id, c_set, manager_id_in,
            NVL (manager_id_in, MANAGER_ID)),
         HIRE_DATE = DECODE (frcflg.hire_date, c_set, hire_date_in,
            NVL (hire_date_in, HIRE_DATE)),
         SALARY = DECODE (frcflg.salary, c_set, salary_in,
            NVL (salary_in, SALARY)),
         COMMISSION = DECODE (frcflg.commission, c_set, commission_in,
            NVL (commission_in, COMMISSION)),
         DEPARTMENT_ID = DECODE (frcflg.department_id, c_set, department_id_in,
            NVL (department_id_in, DEPARTMENT_ID)),
         EMPNO = DECODE (frcflg.empno, c_set, empno_in,
            NVL (empno_in, EMPNO)),
         ENAME = DECODE (frcflg.ename, c_set, ename_in,
            NVL (ename_in, ENAME)),
         CREATED_BY = DECODE (frcflg.created_by, c_set, created_by_in,
            NVL (created_by_in, CREATED_BY)),
         CREATED_ON = DECODE (frcflg.created_on, c_set, created_on_in,
            NVL (created_on_in, CREATED_ON)),
         CHANGED_BY = DECODE (frcflg.changed_by, c_set, changed_by_in,
            NVL (changed_by_in, CHANGED_BY)),
         CHANGED_ON = DECODE (frcflg.changed_on, c_set, changed_on_in,
            NVL (changed_on_in, CHANGED_ON))
       WHERE
          EMPLOYEE_ID = employee_id_in
         ;
      rowcount_out := SQL%ROWCOUNT;
      IF reset_in THEN reset$frc; END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END upd;

   --// Record-based Update --//
   PROCEDURE upd (
      rec_in IN EMPLOYEE%ROWTYPE,
      rowcount_out OUT INTEGER,
      reset_in IN BOOLEAN DEFAULT TRUE)
   IS
   BEGIN
      upd (
         rec_in.EMPLOYEE_ID,
         rec_in.LAST_NAME,
         rec_in.FIRST_NAME,
         rec_in.MIDDLE_INITIAL,
         rec_in.JOB_ID,
         rec_in.MANAGER_ID,
         rec_in.HIRE_DATE,
         rec_in.SALARY,
         rec_in.COMMISSION,
         rec_in.DEPARTMENT_ID,
         rec_in.EMPNO,
         rec_in.ENAME,
         rec_in.CREATED_BY,
         rec_in.CREATED_ON,
         rec_in.CHANGED_BY,
         rec_in.CHANGED_ON,
         rowcount_out,
         reset_in);
   END upd;

--// Insert Processing --//

   --// Initialize record with default values. --//
   FUNCTION initrec (allnull IN BOOLEAN := FALSE) RETURN EMPLOYEE%ROWTYPE
   IS
      retval EMPLOYEE%ROWTYPE;
   BEGIN
      IF allnull THEN NULL; /* Default values are NULL already. */
      ELSE
         retval.EMPLOYEE_ID := NULL;
         retval.LAST_NAME := NULL;
         retval.FIRST_NAME := NULL;
         retval.MIDDLE_INITIAL := NULL;
         retval.JOB_ID := NULL;
         retval.MANAGER_ID := NULL;
         retval.HIRE_DATE := SYSDATE;
         retval.SALARY := NULL;
         retval.COMMISSION := NULL;
         retval.DEPARTMENT_ID := NULL;
         retval.EMPNO := NULL;
         retval.ENAME := NULL;
         retval.CREATED_BY := USER;
         retval.CREATED_ON := SYSDATE;
         retval.CHANGED_BY := USER;
         retval.CHANGED_ON := SYSDATE;
      END IF;
      RETURN retval;
   END;

   --// Initialize record with default values. --//
   PROCEDURE initrec (
      rec_inout IN OUT EMPLOYEE%ROWTYPE,
      allnull IN BOOLEAN := FALSE)
   IS
   BEGIN
      rec_inout := initrec;
   END;

   PROCEDURE ins$ins (
      employee_id_in IN EMPLOYEE.EMPLOYEE_ID%TYPE,
      last_name_in IN EMPLOYEE.LAST_NAME%TYPE DEFAULT NULL,
      first_name_in IN EMPLOYEE.FIRST_NAME%TYPE DEFAULT NULL,
      middle_initial_in IN EMPLOYEE.MIDDLE_INITIAL%TYPE DEFAULT NULL,
      job_id_in IN EMPLOYEE.JOB_ID%TYPE DEFAULT NULL,
      manager_id_in IN EMPLOYEE.MANAGER_ID%TYPE DEFAULT NULL,
      hire_date_in IN EMPLOYEE.HIRE_DATE%TYPE DEFAULT SYSDATE,
      salary_in IN EMPLOYEE.SALARY%TYPE DEFAULT NULL,
      commission_in IN EMPLOYEE.COMMISSION%TYPE DEFAULT NULL,
      department_id_in IN EMPLOYEE.DEPARTMENT_ID%TYPE DEFAULT NULL,
      empno_in IN EMPLOYEE.EMPNO%TYPE DEFAULT NULL,
      ename_in IN EMPLOYEE.ENAME%TYPE DEFAULT NULL,
      created_by_in IN EMPLOYEE.CREATED_BY%TYPE DEFAULT USER,
      created_on_in IN EMPLOYEE.CREATED_ON%TYPE DEFAULT SYSDATE,
      changed_by_in IN EMPLOYEE.CHANGED_BY%TYPE DEFAULT USER,
      changed_on_in IN EMPLOYEE.CHANGED_ON%TYPE DEFAULT SYSDATE,
      upd_on_dup IN BOOLEAN := FALSE
      )
   IS
   BEGIN
      validate (
         hire_date_in,
         created_by_in,
         created_on_in,
         changed_by_in,
         changed_on_in,
         TRUE
         );
      INSERT INTO EMPLOYEE (
         EMPLOYEE_ID
         ,LAST_NAME
         ,FIRST_NAME
         ,MIDDLE_INITIAL
         ,JOB_ID
         ,MANAGER_ID
         ,HIRE_DATE
         ,SALARY
         ,COMMISSION
         ,DEPARTMENT_ID
         ,EMPNO
         ,ENAME
         ,CREATED_BY
         ,CREATED_ON
         ,CHANGED_BY
         ,CHANGED_ON
         )
      VALUES (
         employee_id_in
         ,last_name_in
         ,first_name_in
         ,middle_initial_in
         ,job_id_in
         ,manager_id_in
         ,hire_date_in
         ,salary_in
         ,commission_in
         ,department_id_in
         ,empno_in
         ,ename_in
         ,created_by_in
         ,created_on_in
         ,changed_by_in
         ,changed_on_in
         );
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
         IF NOT NVL (upd_on_dup, FALSE)
         THEN
            RAISE;
         ELSE
            DECLARE
               v_errm VARCHAR2(2000) := SQLERRM;
               v_rowcount INTEGER;
               dotloc INTEGER;
               leftloc INTEGER;
               c_owner ALL_CONSTRAINTS.OWNER%TYPE;
               c_name ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
            BEGIN
               dotloc := INSTR (v_errm,'.');
               leftloc := INSTR (v_errm,'(');
               c_owner :=SUBSTR (v_errm, leftloc+1, dotloc-leftloc-1);
               c_name := SUBSTR (v_errm, dotloc+1, INSTR (v_errm,')')-dotloc-1);

               --// Duplicate based on primary key //--
               IF 'EMP_PK' = c_name AND /* 2000.2 'SCOTT' */ USER = c_owner
               THEN
                  upd (
                     employee_id_in,
                     last_name_in,
                     first_name_in,
                     middle_initial_in,
                     job_id_in,
                     manager_id_in,
                     hire_date_in,
                     salary_in,
                     commission_in,
                     department_id_in,
                     empno_in,
                     ename_in,
                     created_by_in,
                     created_on_in,
                     changed_by_in,
                     changed_on_in,
                     v_rowcount,
                     FALSE
                     );
               ELSE
                  --// Unique index violation. Cannot recover... //--
                  RAISE;
               END IF;
            END;
         END IF;
      WHEN OTHERS
      THEN
         RAISE;
   END ins$ins;


   --// Insert 3: with fields and providing primary key. --//
   PROCEDURE ins (
      employee_id_in IN EMPLOYEE.EMPLOYEE_ID%TYPE,
      last_name_in IN EMPLOYEE.LAST_NAME%TYPE DEFAULT NULL,
      first_name_in IN EMPLOYEE.FIRST_NAME%TYPE DEFAULT NULL,
      middle_initial_in IN EMPLOYEE.MIDDLE_INITIAL%TYPE DEFAULT NULL,
      job_id_in IN EMPLOYEE.JOB_ID%TYPE DEFAULT NULL,
      manager_id_in IN EMPLOYEE.MANAGER_ID%TYPE DEFAULT NULL,
      hire_date_in IN EMPLOYEE.HIRE_DATE%TYPE DEFAULT SYSDATE,
      salary_in IN EMPLOYEE.SALARY%TYPE DEFAULT NULL,
      commission_in IN EMPLOYEE.COMMISSION%TYPE DEFAULT NULL,
      department_id_in IN EMPLOYEE.DEPARTMENT_ID%TYPE DEFAULT NULL,
      empno_in IN EMPLOYEE.EMPNO%TYPE DEFAULT NULL,
      ename_in IN EMPLOYEE.ENAME%TYPE DEFAULT NULL,
      created_by_in IN EMPLOYEE.CREATED_BY%TYPE DEFAULT USER,
      created_on_in IN EMPLOYEE.CREATED_ON%TYPE DEFAULT SYSDATE,
      changed_by_in IN EMPLOYEE.CHANGED_BY%TYPE DEFAULT USER,
      changed_on_in IN EMPLOYEE.CHANGED_ON%TYPE DEFAULT SYSDATE,
      upd_on_dup IN BOOLEAN := FALSE
      )
   IS
   BEGIN
      ins$ins (
         employee_id_in,
         last_name_in,
         first_name_in,
         middle_initial_in,
         job_id_in,
         manager_id_in,
         hire_date_in,
         salary_in,
         commission_in,
         department_id_in,
         empno_in,
         ename_in,
         created_by_in,
         created_on_in,
         changed_by_in,
         changed_on_in,
         upd_on_dup
         );
   END;

   --// Insert 4: with a record and providing primary key. --//
   PROCEDURE ins (rec_in IN EMPLOYEE%ROWTYPE,
      upd_on_dup IN BOOLEAN := FALSE
      )
   IS
   BEGIN
      ins$ins (
         rec_in.EMPLOYEE_ID,
         rec_in.LAST_NAME,
         rec_in.FIRST_NAME,
         rec_in.MIDDLE_INITIAL,
         rec_in.JOB_ID,
         rec_in.MANAGER_ID,
         rec_in.HIRE_DATE,
         rec_in.SALARY,
         rec_in.COMMISSION,
         rec_in.DEPARTMENT_ID,
         rec_in.EMPNO,
         rec_in.ENAME,
         rec_in.CREATED_BY,
         rec_in.CREATED_ON,
         rec_in.CHANGED_BY,
         rec_in.CHANGED_ON,
         upd_on_dup
         );
   END;

--// Delete Processing --//

   PROCEDURE del (
      employee_id_in IN EMPLOYEE.EMPLOYEE_ID%TYPE,
      rowcount_out OUT INTEGER)
   IS
   BEGIN
      DELETE FROM EMPLOYEE
       WHERE
          EMPLOYEE_ID = employee_id_in
         ;
      rowcount_out := SQL%ROWCOUNT;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END del;

   --// Record-based delete --//
   PROCEDURE del
      (rec_in IN pky_rt,
      rowcount_out OUT INTEGER)
   IS
   BEGIN
      del (
         rec_in.employee_id,
         rowcount_out);
   END del;

   PROCEDURE del (rec_in IN EMPLOYEE%ROWTYPE,
      rowcount_out OUT INTEGER)
   IS
   BEGIN
      del (
         rec_in.EMPLOYEE_ID,
         rowcount_out);
   END del;


   --// Program called by database initialization script to pin the package. //--
   PROCEDURE pinme
   IS
   BEGIN
      --// Doesn't do anything except cause the package to be loaded. //--
      NULL;
   END;

--// Initialization section for the package. --//
BEGIN
   NULL; -- Placeholder.
END te_employee;
/
